<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tetrapod Project: Rotations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo1.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tetrapod Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="page_users.html">Users</a></li>  </ul>
</div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Rotations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#rotations_introduction">Introduction</a></li>
<li class="level1"><a href="#rotations_interfaces">Generic Interface</a><ul><li class="level2"><a href="#rotations_interfaces_rotation">Rotation Base Class</a></li>
<li class="level2"><a href="#rotations_interfaces_rotation_constructor">Construction of a Rotation</a></li>
<li class="level2"><a href="#rotations_interfaces_rotation_identity">Identity Rotation</a></li>
<li class="level2"><a href="#rotations_interfaces_rotation_fromVectors">Rotation from Two Vectors</a><ul><li class="level3"><a href="#rotations_interfaces_rotation_unique">Unique Rotation</a></li>
</ul>
</li>
<li class="level2"><a href="#rotations_interfaces_rotation_inverse">Inverse of a Rotation</a></li>
<li class="level2"><a href="#rotations_interfaces_rotation_composition">Composition of a Rotation</a></li>
<li class="level2"><a href="#rotations_interfaces_rotation_rotate">Rotation of a Vector or a Matrix</a></li>
<li class="level2"><a href="#rotations_interfaces_rotation_exponentialmap">Exponential Map and Logarithmic Map</a></li>
<li class="level2"><a href="#rotations_interfaces_rotation_boxoperations">Box Plus and Box Minus Operations</a></li>
<li class="level2"><a href="#rotations_interfaces_conversion">Conversion between Rotations</a><ul><li class="level3"><a href="#rotations_interfaces_conversion_representations">Conversion between Representations</a></li>
<li class="level3"><a href="#rotations_interfaces_conversion_primtype">Conversion between Primitive Data Types</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#rotations_interfaces_representations">Parameterizations</a><ul><li class="level2"><a href="#rotations_interfaces_angleaxis">Angle-Axis</a><ul><li class="level3"><a href="#rotations_implementation_angleaxis_create">Create an Angle-Axis</a></li>
<li class="level3"><a href="#rotations_implementation_angleaxis_use">Use an Angle-Axis</a></li>
</ul>
</li>
<li class="level2"><a href="#rotations_interfaces_rotationvector">Rotation Vector</a><ul><li class="level3"><a href="#rotations_implementation_rotationvector_create">Create a Rotation Vector</a></li>
<li class="level3"><a href="#rotations_implementation_rotationvector_use">Use a Rotation Vector</a></li>
</ul>
</li>
<li class="level2"><a href="#rotations_interfaces_quaternion">Rotation Quaternion</a><ul><li class="level3"><a href="#rotations_implementation_quaternion_create">Create a Rotation Quaternion</a></li>
<li class="level3"><a href="#rotations_implementation_quaternion_use">Use a Quaternion</a></li>
</ul>
</li>
<li class="level2"><a href="#rotations_interfaces_rotationmatrix">Rotation Matrix</a><ul><li class="level3"><a href="#rotations_implementation_rotationmatrix_create">Create a Rotation Matrix</a><ul><li class="level4"><a href="#rotations_implementation_rotationmatrix_use">Use a Rotation Matrix</a></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><a href="#rotations_interfaces_eulerangles_zyx">Euler Angles ZYX</a><ul><li class="level3"><a href="#rotations_implementation_eulerangleszyx_create">Create Euler Angles ZYX</a></li>
<li class="level3"><a href="#rotations_implementation_eulerangleszyx_use">Use  Euler Angles ZYX</a></li>
</ul>
</li>
<li class="level2"><a href="#rotations_interfaces_eulerangles_xyz">Euler Angles XYZ</a><ul><li class="level3"><a href="#rotations_implementation_euleranglesxyz_create">Create Euler Angles XYZ</a></li>
<li class="level3"><a href="#rotations_implementation_euleranglesxyz_use">Use Euler Angles XYZ</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="rotations_introduction"></a>
Introduction</h1>
<p>A rotation between two rigid bodies can be represented by using different parameterizations. The most well-known parameterizations are Euler angles, rotation matrix, angle-axis, rotation vector and unit quaternion. Depending on the application, some representations may be better suited than others. For instance, a unit quaternion does not have singularity issues like Euler angles and are therefore better suited for calculations, but Euler angles are much easier to be interpreted by a user. The library provides therefore a type for each parameterization of a rotation, which enables type safe conversions between different representations.</p>
<p>The type of a rotation further depends on the usage of a rotation. A rotation can be considered either as an active (alibi) or a passive (alibi) transformation. The following figure visualizes the difference: </p><div class="image">
<img src="rotation_active_passive.png" alt=""/>
</div>
<p>The figure shows a rotation about the z-axis with an angle <img class="formulaInl" alt="$\theta$" src="form_7.png"/>. If the rotation is considered as active, the (blue) position vector <img class="formulaInl" alt="${}_A \mathbf{r}_{O\,P}$" src="form_8.png"/> expressed in frame A is rotated to the (green) position vector <img class="formulaInl" alt="${}_A \mathbf{r}_{O\,Q}$" src="form_9.png"/>, which is also expressed in frame A. If the rotation is considered as passive, the (blue) vector <img class="formulaInl" alt="$ {}_A \mathbf{ r}_{O\,P}$" src="form_10.png"/> is not rotated actively, but its coordinates are mapped from frame A to frame B, i.e. the result is <img class="formulaInl" alt="${}_B \mathbf{r}_{O\,P}$" src="form_11.png"/>. In other words, an active rotation rotates a vector, whereas a passive rotation rotates the coordinate frame. The result of rotation applied to a vector or column-wise to a matrix therefore depends on the usage type.</p>
<p>This library provides a passive implementation of different rotation parameterizations. The library depends on the <a href="http://eigen.tuxfamily.org">C++ Eigen library</a>, which already provides some of the representations, but does not feature the type safety and misses many features.</p>
<p>The following section describes the genric interface of all rotation classes, whereas the section <a class="el" href="page_rotations.html#rotations_interfaces_representations">Parameterizations</a> shows the different parameterizations and explains how to use them.</p>
<h1><a class="anchor" id="rotations_interfaces"></a>
Generic Interface</h1>
<h2><a class="anchor" id="rotations_interfaces_rotation"></a>
Rotation Base Class</h2>
<p>The class <a class="el" href="classkindr_1_1RotationBase.html" title="Representation of a generic rotation.">kindr::RotationBase</a> serves as an interface for a rotation between two rigid bodies. All types of representations of a rotation, such as quaternion, angle-axis, and Euler angles, are derived from this base class.</p>
<p>The type of a rotation is defined by</p><ul>
<li>the <a class="el" href="page_rotations.html#rotations_interfaces_representations">kind of parameterization</a> (angle-axis, quaternion, etc.) and</li>
<li>the primitive data type of the parameters (float/double, etc.).</li>
</ul>
<h2><a class="anchor" id="rotations_interfaces_rotation_constructor"></a>
Construction of a Rotation</h2>
<p>The default constructor of a rotation always creates an identity rotation. If the library is built with debugging symbols, an assertion is thrown if a rotation is constructed with parameter values that do not represent a valid rotation.</p>
<h2><a class="anchor" id="rotations_interfaces_rotation_identity"></a>
Identity Rotation</h2>
<p>Any rotation can be set equal to the identity rotation by the method <a class="el" href="classkindr_1_1RotationBase.html#aad3997140e6950ccc93e7be822959e2e">setIdentity()</a>.</p>
<h2><a class="anchor" id="rotations_interfaces_rotation_fromVectors"></a>
Rotation from Two Vectors</h2>
<p>A rotation that describes the relative orientation of two vectors can be initialized by means of the method <a class="el" href="classkindr_1_1RotationBase.html#a31d35d5050c98630adc1895216e47a3b">setFromVectors()</a>. </p>
<h3><a class="anchor" id="rotations_interfaces_rotation_unique"></a>
Unique Rotation</h3>
<p>A rotation can be represented in different ways. The quaternion <img class="formulaInl" alt="$Q = q_0 + q_1 i + q_2 j + q_3 k$" src="form_12.png"/> and the quaternion <img class="formulaInl" alt="$Q = -q_0 - q_1 i - q_2 j - q_3 k$" src="form_13.png"/>, for instance, represent the same rotation. However, sometimes a unique representation is desired.</p>
<p>A unique representation is obtained by</p><ul>
<li><a class="el" href="classkindr_1_1RotationBase.html#a3b6393e323287c998bc6c567c10c80c3">getUnique()</a>: gets a copy of the presentation, which is unique, and</li>
<li><a class="el" href="classkindr_1_1RotationBase.html#a1f292f64472c281db756012b632707df">setUnique()</a>: sets the representation to the unique representation.</li>
</ul>
<p>Note that numerical issues may cause problems when this method is used to compare two rotations. We therefore recommend to use the method <a class="el" href="classkindr_1_1RotationBase.html#ad674b4668d1a171b5efa7df9ba25b38f">isNear()</a> (see below).</p>
<h2><a class="anchor" id="rotations_interfaces_rotation_inverse"></a>
Inverse of a Rotation</h2>
<p>The inverse of a rotation is provided by two methods:</p><ul>
<li><a class="el" href="classkindr_1_1RotationBase.html#a8db8faa8dddad01a41699dd926c2420f">invert()</a> returns and stores the inverse</li>
<li><a class="el" href="classkindr_1_1RotationBase.html#a1cbe632e37e0a054e2f123d3d0889cf6">inverted()</a> returns only the inverse</li>
</ul>
<h2><a class="anchor" id="rotations_interfaces_rotation_composition"></a>
Composition of a Rotation</h2>
<p>A rotation can be composed of other rotations. The multiplication operator enables to concatenate rotations as follows: </p><div class="fragment"><div class="line">C_DA = C_DC*C_CB*C_BA;</div>
</div><!-- fragment --><p> Due to numerical issues, the result of the concatenation may become an invalid rotation. Due to speed considerations, the user is responsible to guarentee that the parameter values represent a valid rotation. The library therefore offers the method <a class="el" href="classkindr_1_1RotationBase.html#a0d56418383e3cbad4ddbe3d00553245d">fix()</a> to project the parameters to the admissible space. The method would, for instance, normalize the rotation quaternion.</p>
<h2><a class="anchor" id="rotations_interfaces_rotation_rotate"></a>
Rotation of a Vector or a Matrix</h2>
<p>To rotate a vector or a matrix columnwise, the following methods are provided:</p><ul>
<li><a class="el" href="classkindr_1_1RotationBase.html#a0b461d729f66615029629fa37bc69ed3">rotate()</a>: rotates a vector or a matrix columnwise</li>
<li><a class="el" href="classkindr_1_1RotationBase.html#a558a7f1b1963413c7fee33bde168ef96">inverseRotate()</a>: reverse rotates a vector or a matrix columnwise</li>
</ul>
<h2><a class="anchor" id="rotations_interfaces_rotation_exponentialmap"></a>
Exponential Map and Logarithmic Map</h2>
<p>The exponential map maps a vector in <img class="formulaInl" alt="$\mathsf{R}^3$" src="form_14.png"/> describing the axis and magnitude of a three degree-of-freedom rotation to the corresponding rotation parameterization. The mapping is provided by the method <a class="el" href="classkindr_1_1RotationBase.html#ab795e76e48ab2474240721ebc49cde6f">exponentialMap()</a>. The corresponding logarithmic map is provided by the method <a class="el" href="classkindr_1_1RotationBase.html#a691cf4b267164a964a462380e324126e">logarithmicMap()</a>.</p>
<h2><a class="anchor" id="rotations_interfaces_rotation_boxoperations"></a>
Box Plus and Box Minus Operations</h2>
<p>The box plus operation defined as <img class="formulaInl" alt="$\mathcal{R}_2 = \mathcal{R}_1\boxplus\mathbf{v} = \mathcal{R}(e^{\hat{\mathbf{v}}}) \cdot \mathcal{R}_1 $" src="form_15.png"/>, where <img class="formulaInl" alt="$\mathcal{R}$" src="form_16.png"/> is a rotation, <img class="formulaInl" alt="$\mathbf{v}$" src="form_17.png"/> is a vector in <img class="formulaInl" alt="$\mathsf{R}^3$" src="form_14.png"/> and <img class="formulaInl" alt="$\hat{}$" src="form_18.png"/> maps a vector to the skew-symmetric matrix corresponding to the cross product, is provided by the method <a class="el" href="classkindr_1_1RotationBase.html#a65c48f330b3f92db8ecf2f2c539265ea">boxPlus()</a>.</p>
<p>The box minus operation defined as <img class="formulaInl" alt="$\mathbf{v} = \mathcal{R}_1\boxminus\mathcal{R}_2 = \ln{(\mathcal{R}_1\cdot\mathcal{R}_2^{-1})}\check{}$" src="form_19.png"/> is provided by the method <a class="el" href="classkindr_1_1RotationBase.html#a96158c21692da59bce4ae0eb7025802f">boxMinus()</a>.</p>
<p>\subection rotations_interfaces_comparison Comparison of Rotations To compare two rotations, the equal operator (operator==) can be used to check if a rotation is equal to another rotation.</p>
<p>Small numeric errors may however lead to a wrong result. Therefore, the function <a class="el" href="classkindr_1_1RotationBase.html#ad674b4668d1a171b5efa7df9ba25b38f">isNear()</a> compares two rotations using a measure.</p>
<p>The difference between two rotations can be obtained by the method <a class="el" href="classkindr_1_1RotationBase.html#a8a41839de5d7ff9cb702b6c9fceae9b6">getDisparityAngle()</a>.</p>
<h2><a class="anchor" id="rotations_interfaces_conversion"></a>
Conversion between Rotations</h2>
<p>There are two kinds of conversions:</p><ul>
<li>Conversion between different representations, i.e. between different parameterizations (e.g. rotation quaternion - angle-axis)</li>
<li>Conversion between different primitive data types (e.g. float - double)</li>
</ul>
<h3><a class="anchor" id="rotations_interfaces_conversion_representations"></a>
Conversion between Representations</h3>
<p>The following methods allow to convert between different representations of a rotation: </p><div class="fragment"><div class="line">AngleAxisD angleAxis;</div>
<div class="line">RotationQuaternionD quaternion(angleAxis);  <span class="comment">// constructor</span></div>
<div class="line">angleAxis = quaternion;             <span class="comment">// assignment operator</span></div>
<div class="line">quaternion(angleAxis);              <span class="comment">// parenthesis operator</span></div>
</div><!-- fragment --><h3><a class="anchor" id="rotations_interfaces_conversion_primtype"></a>
Conversion between Primitive Data Types</h3>
<p>The conversion between different primitive data types (double/float) works the same way as the conversion between different representations.</p>
<h1><a class="anchor" id="rotations_interfaces_representations"></a>
Parameterizations</h1>
<p>The following representations are currently provided by the library:</p>
<h2><a class="anchor" id="rotations_interfaces_angleaxis"></a>
Angle-Axis</h2>
<p>The class <a class="el" href="classkindr_1_1AngleAxis.html">AngleAxis</a> provides an angle-axis representation of a rotation:</p>
<p><img class="formulaInl" alt="$\boxed{(\theta, \mathbf{n}), \quad \lVert \mathbf{n} \rVert = 1,}$" src="form_20.png"/></p>
<p>where <img class="formulaInl" alt="$\theta \in \mathbb{R}$" src="form_21.png"/> is the rotation angle and <img class="formulaInl" alt="$\mathbf{n} \in \mathbb{R}^3$" src="form_22.png"/> is the rotation axis with unit length.</p>
<p>The angle and rotation axis ared stored in Eigen::AngleAxis.</p>
<p>The following typedefs are provided for convenience:</p><ul>
<li>AngleAxisD for primitive type double</li>
<li>AngleAxisF for primitive type float</li>
</ul>
<h3><a class="anchor" id="rotations_implementation_angleaxis_create"></a>
Create an Angle-Axis</h3>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> angle = 0.2;</div>
<div class="line"><span class="keywordtype">double</span> n_1 = 1.0;</div>
<div class="line"><span class="keywordtype">double</span> n_2 = 0.0;</div>
<div class="line"><span class="keywordtype">double</span> n_3 = 0.0;</div>
<div class="line">Eigen::Vector3d axis(n_1, n_2, n_3);</div>
<div class="line">AngleAxisD angleAxis1; <span class="comment">// identity rotation: angle = 0.0 axis = (1.0, 0.0, 0.0)</span></div>
<div class="line">AngleAxisD angleAxis2(angle, axis);</div>
<div class="line">AngleAxisD angleAxis3(angle, n_1, n_2, n_3);</div>
<div class="line">AngleAxisD angleAxis4(angle, 1.0, 1.0, 1.0); <span class="comment">// will create an error in debug mode</span></div>
</div><!-- fragment --><h3><a class="anchor" id="rotations_implementation_angleaxis_use"></a>
Use an Angle-Axis</h3>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> angle = angleAxis.angle();                                   <span class="comment">// get rotation angle </span></div>
<div class="line">Eigen::Vector3d axis = angleAxis.axis();                                <span class="comment">// get rotation axis</span></div>
<div class="line">Eigen::AngleAxisd angleAxisEigen = angleAxis.toImplementation();                    <span class="comment">// get Eigen angle-axis</span></div>
<div class="line">Eigen::Vector3d vector_rotated = angleAxis.rotate(Eigen::Vector3d(1.0,2.0,3.0));            <span class="comment">// rotate a vector</span></div>
<div class="line">Eigen::Vector3d vector_invrotated = angleAxis.inverseRotate(Eigen::Vector3d(1.0,2.0,3.0));      <span class="comment">// reverse rotate a vector</span></div>
<div class="line">angleAxis.setUnique();                                      <span class="comment">// Modifies the angle such that it is in [0,PI)</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Angle-Axis: &quot;</span> &lt;&lt; angleAxis &lt;&lt; std::endl:                      <span class="comment">// output angle-axis</span></div>
<div class="line"><span class="keywordflow">if</span> (angleAxis == AngleAxisD(M_PI/2.0, 1.0, 0.0, 0.0))                           <span class="comment">// compare angle-axis</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Rotation is about x-axis with angle M_PI/2.0\n&quot;</span>; </div>
</div><!-- fragment --><h2><a class="anchor" id="rotations_interfaces_rotationvector"></a>
Rotation Vector</h2>
<p>The class <a class="el" href="classkindr_1_1RotationVector.html" title="Implementation of a rotation vector based on Eigen::Matrix&lt;Scalar, 3, 1&gt;">kindr::RotationVector</a> implements a rotation vector representation of a rotation:</p>
<p><img class="formulaInl" alt="$\boxed{\mathbf{\phi}\in\mathbb{R}^3}$" src="form_23.png"/></p>
<p>where <img class="formulaInl" alt="$\lVert \mathbf{\phi} \rVert $" src="form_24.png"/> is the rotation angle and <img class="formulaInl" alt="$\frac{\mathbf{\phi}}{\lVert \mathbf{\phi} \rVert}$" src="form_25.png"/> is the rotation axis.</p>
<p>It stores the rotation vector in Eigen::Matrix&lt;Scalar, 3, 1&gt;.</p>
<p>The following typedefs are provided for convenience:</p><ul>
<li>RotationVectorD for primitive type double</li>
<li>RotationVectorF for primitive type float</li>
</ul>
<h3><a class="anchor" id="rotations_implementation_rotationvector_create"></a>
Create a Rotation Vector</h3>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> v_1 = 2.0;</div>
<div class="line"><span class="keywordtype">double</span> v_2 = 0.0;</div>
<div class="line"><span class="keywordtype">double</span> v_3 = 0.0;</div>
<div class="line">Eigen::Vector3d vector(v_1, v_2, v_3);</div>
<div class="line">RotationVectorD rotationVector1; <span class="comment">// identity rotation: vector = (0.0, 0.0, 0.0)</span></div>
<div class="line">RotationVectorD rotationVector2(vector);</div>
<div class="line">RotationVectorD rotationVector3(v_1, v_2, v_3);</div>
</div><!-- fragment --><h3><a class="anchor" id="rotations_implementation_rotationvector_use"></a>
Use a Rotation Vector</h3>
<div class="fragment"><div class="line">Eigen::Vector3d vector = rotationVector.vector();                               <span class="comment">// get Eigen vector</span></div>
<div class="line">Eigen::Vector3d vector_rotated = rotationVector.rotate(Eigen::Vector3d(1.0,2.0,3.0));           <span class="comment">// rotate a vector</span></div>
<div class="line">Eigen::Vector3d vector_invrotated = rotationVector.inverseRotate(Eigen::Vector3d(1.0,2.0,3.0));     <span class="comment">// reverse rotate a vector</span></div>
<div class="line">rotationVector.setUnique();                                         <span class="comment">// Modifies the angle such that it is in [0,PI)</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Rotation Vector: &quot;</span> &lt;&lt; rotationVector &lt;&lt; std::endl:                        <span class="comment">// output angle-axis</span></div>
<div class="line"><span class="keywordflow">if</span> (rotationVector == RotationVectorD(M_PI/2.0, 0.0, 0.0))                          <span class="comment">// compare rotation vector</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Rotation is about x-axis with angle M_PI/2.0\n&quot;</span>; </div>
</div><!-- fragment --><h2><a class="anchor" id="rotations_interfaces_quaternion"></a>
Rotation Quaternion</h2>
<p>The class <a class="el" href="classkindr_1_1RotationQuaternion.html" title="Implementation of quaternion rotation based on Eigen::Quaternion.">kindr::RotationQuaternion</a> implements a Hamiltonian unit quaternion representation of a rotation:</p>
<p><img class="formulaInl" alt="$\boxed{\begin{aligned}Q &amp;= q_0 + q_1 i + q_2 j + q_3 k \in \mathbb{H}, \quad q_i \in \mathbb{R} \\ i^2 &amp;= j^2=k^2 = ijk = -1, \quad \lVert Q \rVert= \sqrt{q_0^2 + q_1^2 + q_2^2 + q_3^2} = 1 \\ \end{aligned}}$" src="form_26.png"/></p>
<p>It stores the coefficients according to the <a class="el" href="classkindr_1_1UnitQuaternion.html" title="Implementation of a unit quaternion based on Eigen::Quaternion.">kindr::UnitQuaternion</a>. See also Chapter Quternions for more information.</p>
<p>The following typedefs are provided for convenience:</p><ul>
<li>RotationQuaternionD for primitive type double</li>
<li>RotationQuaternionF for primitive type float</li>
</ul>
<h3><a class="anchor" id="rotations_implementation_quaternion_create"></a>
Create a Rotation Quaternion</h3>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> p_0 = 1.0;</div>
<div class="line"><span class="keywordtype">double</span> p_1 = 0.0;</div>
<div class="line"><span class="keywordtype">double</span> p_2 = 0.0;</div>
<div class="line"><span class="keywordtype">double</span> p_3 = 0.0;</div>
<div class="line">RotationQuaternionD rquat1;                                 <span class="comment">// identity rotation: (1.0, 0.0, 0.0, 0.0)</span></div>
<div class="line">RotationQuaternionD rquat2(p_0, p_1, p_2, p_3);                 <span class="comment">// create with four scalars</span></div>
<div class="line">RotationQuaternionD rquat3(Eigen::Quaterniond(p_0, p_1, p_2, p_3));         <span class="comment">// create with Eigen quaternion</span></div>
<div class="line">RotationQuaternionD rquat5(UnitQuaternion(p_0, p_1, p_2, p_3));         <span class="comment">// create with unit quaternion</span></div>
<div class="line">RotationQuaternionD rquat5(Quaternion(p_0, p_1, p_2, p_3));         <span class="comment">// create with quaternion</span></div>
<div class="line">RotationQuaternionD rquat4(1.0, 1.0, 1.0, 1.0);                     <span class="comment">// will create an error in debug mode</span></div>
</div><!-- fragment --><h3><a class="anchor" id="rotations_implementation_quaternion_use"></a>
Use a Quaternion</h3>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> p_0 = rquat.w();                                   </div>
<div class="line"><span class="keywordtype">double</span> p_1 = rquat.x();</div>
<div class="line"><span class="keywordtype">double</span> p_2 = rquat.y();</div>
<div class="line"><span class="keywordtype">double</span> p_3 = rquat.z();</div>
<div class="line">Eigen::Quaterniond quatEigen = rquat.toImplementation();                      <span class="comment">// get Eigen quaternion</span></div>
<div class="line">UnitQuaternionD uquat = rquat.toUnitQuaternion();                         <span class="comment">// get unit quaternion</span></div>
<div class="line">Eigen::Vector3d vector_rotated = rquat.rotate(Eigen::Vector3d(1.0,2.0,3.0));              <span class="comment">// rotate a vector</span></div>
<div class="line">Eigen::Vector3d vector_invrotated = rquat.inverseRotate(Eigen::Vector3d(1.0,2.0,3.0));        <span class="comment">// reverse rotate a vector</span></div>
<div class="line">rquat.setUnique();                                            <span class="comment">// Modifies the quaternion such that p_0 &gt;= 0</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Quaternion: &quot;</span> &lt;&lt; rquat &lt;&lt; std::endl:                            <span class="comment">// output quaternion</span></div>
<div class="line"><span class="keywordflow">if</span> (rquat == RotationQuaternionD())                                   <span class="comment">// compare </span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Rotation is identity\n&quot;</span>; </div>
</div><!-- fragment --><h2><a class="anchor" id="rotations_interfaces_rotationmatrix"></a>
Rotation Matrix</h2>
<p>The class <a class="el" href="classkindr_1_1RotationMatrix.html" title="Implementation of matrix rotation based on Eigen::Matrix&lt;Scalar, 3, 3&gt;">kindr::RotationMatrix</a> implements a 3x3 rotation matrix representation of a rotation:</p>
<p><img class="formulaInl" alt="$\boxed{R = \begin{bmatrix} r_{11} &amp; r_{12} &amp; r_{13} \\ r_{21} &amp; r_{22} &amp; r_{23} \\ r_{31} &amp; r_{32} &amp; r_{33} \end{bmatrix} \in SO(3)}$" src="form_27.png"/></p>
<p>It stores the coefficients in Eigen::Matrix.</p>
<p>The following typedefs are provided for convenience:</p><ul>
<li>RotationMatrixD for primitive type double</li>
<li>RotationMatrixF for primitive type float</li>
</ul>
<h3><a class="anchor" id="rotations_implementation_rotationmatrix_create"></a>
Create a Rotation Matrix</h3>
<div class="fragment"><div class="line">RotationMatrixD rmat1;           <span class="comment">// identity rotation: diag(1.0, 1.0, 1.0)</span></div>
<div class="line">RotationMatrixD rmat2(r11, r12, r13, <span class="comment">// rotation matrix from coefficients</span></div>
<div class="line">           r21 ,r22, r23,</div>
<div class="line">           r31, r32, r33);</div>
<div class="line">Eigen::Matrix3d mat;             <span class="comment">// rotation matrix from Eigen matrix</span></div>
<div class="line">mat &lt;&lt; r11, r12, r13,</div>
<div class="line">   r21 ,r22, r23,</div>
<div class="line">   r31, r32, r33;</div>
<div class="line">RotationMatrixD rmat3(mat);      <span class="comment">// using the constructor   </span></div>
<div class="line">RotationMatrixD rmat4;           <span class="comment">// using a setter</span></div>
<div class="line">rmat4.setMatrix(mat);</div>
</div><!-- fragment --><h4><a class="anchor" id="rotations_implementation_rotationmatrix_use"></a>
Use a Rotation Matrix</h4>
<div class="fragment"><div class="line">Eigen::Matrix3d mat = rmat.matrix();                                  <span class="comment">// get Eigen matrix (avoid using toImplementation())    </span></div>
<div class="line">Eigen::Vector3d vector_rotated = rmat.rotate(Eigen::Vector3d(1.0,2.0,3.0));               <span class="comment">// rotate a vector</span></div>
<div class="line">Eigen::Vector3d vector_invrotated = rmat.inverseRotate(Eigen::Vector3d(1.0,2.0,3.0));         <span class="comment">// reverse rotate a vector</span></div>
<div class="line"><span class="keywordtype">double</span> determinant = rmat.determinant();                              <span class="comment">// get the determinant of the matrix</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Rotation matrix: &quot;</span> &lt;&lt; rmat &lt;&lt; std::endl:                        <span class="comment">// output rotation matrix</span></div>
<div class="line"><span class="keywordflow">if</span> (rmat == RotationMatrixD())                                    <span class="comment">// compare </span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Rotation is identity\n&quot;</span>; </div>
</div><!-- fragment --><p>Note that the rotation matrix is stored internally differently than created by the constructor! Therefore, you should access the matrix using the method <a class="el" href="classkindr_1_1RotationMatrix.html#a93ccfb7b70e137d66693fac5f80a5049">matrix()</a> instead of <a class="el" href="classkindr_1_1RotationMatrix.html#aaa56dc1cf71facd568c2dc878cb51500">toImplementation()</a>.</p>
<h2><a class="anchor" id="rotations_interfaces_eulerangles_zyx"></a>
Euler Angles ZYX</h2>
<p>The class <a class="el" href="classkindr_1_1EulerAnglesZyx.html" title="Implementation of Euler angles (intrinsic Z-Y&#39;-X&#39;&#39;, a.k.a. extrinsic x-y-z, a.k.a....">kindr::EulerAnglesZyx</a> implements the Euler Angles using the Z-Y-X convention:</p>
<p><img class="formulaInl" alt="$\boxed{(z, y, x),}$" src="form_28.png"/></p>
<p>where <img class="formulaInl" alt="$z$" src="form_29.png"/> is the yaw angle, <img class="formulaInl" alt="$y$" src="form_30.png"/> is the pitch angle, and <img class="formulaInl" alt="$x$" src="form_31.png"/> is the roll angle. The consecutive rotations are shown in the following picture: </p><div class="image">
<img src="EulerAnglesZyx.png" alt=""/>
</div>
<p>The following typedefs are provided for convenience:</p><ul>
<li>EulerAnglesZyxD for primitive type double</li>
<li>EulerAnglesZyxF for primitive type float</li>
</ul>
<h3><a class="anchor" id="rotations_implementation_eulerangleszyx_create"></a>
Create Euler Angles ZYX</h3>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> yaw = 0.3;                 <span class="comment">// angle around z-axis</span></div>
<div class="line"><span class="keywordtype">double</span> pitch = 0.2;                   <span class="comment">// angle around new y-axis</span></div>
<div class="line"><span class="keywordtype">double</span> roll = 0.1;                    <span class="comment">// angle around new x-axis</span></div>
<div class="line">EulerAnglesZyxD angles1;              <span class="comment">// identity rotation (0, 0, 0)</span></div>
<div class="line">EulerAnglesZyxD angles2(yaw, pitch, roll);        </div>
<div class="line">EulerAnglesZyxD angles3(Eigen::Vector3d(yaw, pitch, roll));       </div>
</div><!-- fragment --><h3><a class="anchor" id="rotations_implementation_eulerangleszyx_use"></a>
Use  Euler Angles ZYX</h3>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> roll = angles.roll();</div>
<div class="line"><span class="keywordtype">double</span> pitch = angles.pitch();</div>
<div class="line"><span class="keywordtype">double</span> yaw = angles.yaw();</div>
<div class="line">roll = angles.x();</div>
<div class="line">pitch = angles.y();</div>
<div class="line">yaw = angles.z();</div>
<div class="line">Eigen::Vector3d angleVector = angles.vector();    <span class="comment">// [roll; pitch; yaw]</span></div>
<div class="line">angles.setUnique()                        <span class="comment">// Modifies the angles, such that yaw in [-pi,pi), pitch in [-pi/2,pi/2), roll in [-pi,pi)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="rotations_interfaces_eulerangles_xyz"></a>
Euler Angles XYZ</h2>
<p>The class <a class="el" href="classkindr_1_1EulerAnglesXyz.html" title="Implementation of Euler angles (X-Y&#39;-Z&#39;&#39; / roll-pitch-yaw) rotation based on Eigen::Matrix&lt;Scalar,...">kindr::EulerAnglesXyz</a> implements the Euler Angles using the X-Y-Z convention:</p>
<p><img class="formulaInl" alt="$\boxed{(x, y, z ),}$" src="form_32.png"/></p>
<p>where <img class="formulaInl" alt="$z$" src="form_29.png"/> is the yaw angle, <img class="formulaInl" alt="$y$" src="form_30.png"/> is the pitch angle, and <img class="formulaInl" alt="$x$" src="form_31.png"/> is the roll angle. The consecutive rotations are shown in the following picture: </p><div class="image">
<img src="EulerAnglesXyz.png" alt=""/>
</div>
<p>It stores the coefficients in Eigen::Vector3.</p>
<p>The following four typedefs are provided for convenience:</p><ul>
<li>EulerAnglesXyzD for primitive type double</li>
<li>EulerAnglesXyzF for primitive type float</li>
</ul>
<h3><a class="anchor" id="rotations_implementation_euleranglesxyz_create"></a>
Create Euler Angles XYZ</h3>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> roll = 0.1;                    <span class="comment">// angle around x-axis</span></div>
<div class="line"><span class="keywordtype">double</span> pitch = 0.2;                   <span class="comment">// angle around new y-axis</span></div>
<div class="line"><span class="keywordtype">double</span> yaw = 0.3;                 <span class="comment">// angle around new z-axis</span></div>
<div class="line">EulerAnglesXyzD angles1;              <span class="comment">// identity rotation (0, 0, 0)</span></div>
<div class="line">EulerAnglesXyzD angles2(roll, pitch, yaw);        </div>
<div class="line">EulerAnglesXyzD angles3(Eigen::Vector3d(roll, pitch, yaw));</div>
</div><!-- fragment --><h3><a class="anchor" id="rotations_implementation_euleranglesxyz_use"></a>
Use Euler Angles XYZ</h3>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> roll = angles.roll();</div>
<div class="line"><span class="keywordtype">double</span> pitch = angles.pitch();</div>
<div class="line"><span class="keywordtype">double</span> yaw = angles.yaw();</div>
<div class="line">roll = angles.x();</div>
<div class="line">pitch = angles.y();</div>
<div class="line">yaw = angles.z();</div>
<div class="line">Eigen::Vector3d angleVector = angles.vector();    <span class="comment">// [roll; pitch; yaw]</span></div>
<div class="line">angles.setUnique()                        <span class="comment">// Modifies the angles, such that roll in [-pi,pi), pitch in [-pi/2,pi/2), yaw in [-pi,pi)</span></div>
</div><!-- fragment --><p><br  />
 <br  />
 <br  />
 <br  />
 <br  />
 <br  />
 <br  />
 <br  />
 <br  />
 <br  />
 <br  />
 <br  />
 <br  />
 <br  />
 <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
