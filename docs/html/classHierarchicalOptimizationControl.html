<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tetrapod Project: HierarchicalOptimizationControl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo1.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tetrapod Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classHierarchicalOptimizationControl-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HierarchicalOptimizationControl Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for hierarchical optimization control.  
 <a href="classHierarchicalOptimizationControl.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hierarchical__optimization__controller_8h_source.html">hierarchical_optimization_controller.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for HierarchicalOptimizationControl:</div>
<div class="dyncontent">
<div class="center"><img src="classHierarchicalOptimizationControl__coll__graph.png" border="0" usemap="#HierarchicalOptimizationControl_coll__map" alt="Collaboration graph"/></div>
<map name="HierarchicalOptimizationControl_coll__map" id="HierarchicalOptimizationControl_coll__map">
<area shape="rect" title="A class for hierarchical optimization control." alt="" coords="5,95,189,136"/>
<area shape="rect" href="classKinematics.html" title="A class for analytical Kinematics Solving." alt="" coords="50,5,145,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHierarchicalOptimizationControl_1_1Task.html">Task</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structHierarchicalOptimizationControl_1_1Task.html" title="Task struct.">Task</a> struct.  <a href="structHierarchicalOptimizationControl_1_1Task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae49f08ceaee8df6933d8708fb68c3b99"><td class="memItemLeft" align="right" valign="top"><a id="ae49f08ceaee8df6933d8708fb68c3b99"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#ae49f08ceaee8df6933d8708fb68c3b99">SolverType</a> { <br />
&#160;&#160;<b>OSQP</b> = 1, 
<b>ECQP</b> = 2, 
<b>CLP</b> = 3, 
<b>SCS</b> = 4, 
<br />
&#160;&#160;<b>SNOPT</b> = 5, 
<b>UNSPECIFIED</b>
<br />
 }</td></tr>
<tr class="memdesc:ae49f08ceaee8df6933d8708fb68c3b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drake Solver type enumerator. <br /></td></tr>
<tr class="separator:ae49f08ceaee8df6933d8708fb68c3b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595a20872c103fe6c0332012648d9b9e"><td class="memItemLeft" align="right" valign="top"><a id="a595a20872c103fe6c0332012648d9b9e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a595a20872c103fe6c0332012648d9b9e">LegType</a> { <br />
&#160;&#160;<b>frontLeft</b> = 1, 
<b>frontRight</b> = 2, 
<b>rearLeft</b> = 3, 
<b>rearRight</b> = 4, 
<br />
&#160;&#160;<b>NONE</b>
<br />
 }</td></tr>
<tr class="memdesc:a595a20872c103fe6c0332012648d9b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leg type enumerator. <br /></td></tr>
<tr class="separator:a595a20872c103fe6c0332012648d9b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6def6e783d9ce5400d931e7d6da2ad36"><td class="memItemLeft" align="right" valign="top"><a id="a6def6e783d9ce5400d931e7d6da2ad36"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a6def6e783d9ce5400d931e7d6da2ad36">BodyType</a> { <br />
&#160;&#160;<b>base</b> = 1, 
<b>hip</b> = 2, 
<b>thigh</b> = 3, 
<b>leg</b> = 4, 
<br />
&#160;&#160;<b>foot</b> = 5
<br />
 }</td></tr>
<tr class="memdesc:a6def6e783d9ce5400d931e7d6da2ad36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Body type enumerator. <br /></td></tr>
<tr class="separator:a6def6e783d9ce5400d931e7d6da2ad36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2dcfaa71130d1c120477ab120589c662"><td class="memItemLeft" align="right" valign="top"><a id="a2dcfaa71130d1c120477ab120589c662"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a2dcfaa71130d1c120477ab120589c662">HierarchicalOptimizationControl</a> ()</td></tr>
<tr class="memdesc:a2dcfaa71130d1c120477ab120589c662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a2dcfaa71130d1c120477ab120589c662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad296c50c35b6eaabf210c82c3c756201"><td class="memItemLeft" align="right" valign="top"><a id="ad296c50c35b6eaabf210c82c3c756201"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#ad296c50c35b6eaabf210c82c3c756201">~HierarchicalOptimizationControl</a> ()</td></tr>
<tr class="memdesc:ad296c50c35b6eaabf210c82c3c756201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ad296c50c35b6eaabf210c82c3c756201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2515ead8270fb9a8015cec81f1d1678"><td class="memItemLeft" align="right" valign="top"><a id="ae2515ead8270fb9a8015cec81f1d1678"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>StaticTorqueTest</b> ()</td></tr>
<tr class="separator:ae2515ead8270fb9a8015cec81f1d1678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911cef032be8319e4ed16b0a26dd8804"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 12, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a911cef032be8319e4ed16b0a26dd8804">HierarchicalOptimization</a> (const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;_desired_base_pos, const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;_desired_base_vel, const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;_desired_base_acc, const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;_desired_base_ori, const Eigen::Matrix&lt; Eigen::Vector3d, 4, 1 &gt; &amp;_desired_f_pos, const Eigen::Matrix&lt; Eigen::Vector3d, 4, 1 &gt; &amp;_desired_f_vel, const Eigen::Matrix&lt; Eigen::Vector3d, 4, 1 &gt; &amp;_desired_f_acc, const Eigen::Matrix&lt; Eigen::Vector3d, 4, 1 &gt; &amp;_f_pos, const Eigen::Matrix&lt; Eigen::Vector3d, 4, 1 &gt; &amp;_f_vel, const Eigen::Matrix&lt; double, 18, 1 &gt; &amp;_q, const Eigen::Matrix&lt; double, 18, 1 &gt; &amp;_u, const int &amp;_v=0)</td></tr>
<tr class="memdesc:a911cef032be8319e4ed16b0a26dd8804"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HierarchicalOptimization function finds the optimal joint torques for a desired motion plan. It finds joint torques by finding optimal joint accelerations and contact forces for a set of whole-body control QP tasks, and leveraging inverse dynamics.  <a href="classHierarchicalOptimizationControl.html#a911cef032be8319e4ed16b0a26dd8804">More...</a><br /></td></tr>
<tr class="separator:a911cef032be8319e4ed16b0a26dd8804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f7ef31eba78810a479bc70ecd26543"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a64f7ef31eba78810a479bc70ecd26543">HierarchicalQPOptimization</a> (const int &amp;_state_dim, const std::vector&lt; <a class="el" href="structHierarchicalOptimizationControl_1_1Task.html">Task</a> &gt; &amp;_tasks, const <a class="el" href="classHierarchicalOptimizationControl.html#ae49f08ceaee8df6933d8708fb68c3b99">SolverType</a> &amp;_solver=SolverType::OSQP, const int &amp;_v=0)</td></tr>
<tr class="memdesc:a64f7ef31eba78810a479bc70ecd26543"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HierarchicalQPOptimization function finds the optimal solution for a set of tasks in a strictly prioritized order. The method iterates through the set of tasks and searches for a new solution in the null-space of all higher priority equality constraints. At each iteration a QP problem is solved to find a vector lying in the row-space of the null-space of all equality constraints, which improve on the current solution.  <a href="classHierarchicalOptimizationControl.html#a64f7ef31eba78810a479bc70ecd26543">More...</a><br /></td></tr>
<tr class="separator:a64f7ef31eba78810a479bc70ecd26543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5be7152ab8fe0eb6dcb595aa5d961b5"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#aa5be7152ab8fe0eb6dcb595aa5d961b5">HierarchicalLeastSquareOptimization</a> (const Eigen::Matrix&lt; Eigen::MatrixXd, Eigen::Dynamic, 1 &gt; &amp;_A, const Eigen::Matrix&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;, Eigen::Dynamic, 1 &gt; &amp;_b, const int &amp;_v=0)</td></tr>
<tr class="memdesc:aa5be7152ab8fe0eb6dcb595aa5d961b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HierarchicalLeastSquareOptimization function finds the optimal solution for a set of linear equality constraints in a strictly prioritized order. The method iterates through the set of equality constraints and searches for a new solution in the null-space of all higher priority equality constraints. At each iteration the Moore-Penrose pseudoinverse is utilized to find a vector lying in the row-space of the null-space of all equality constraints, which improve on the current solution. The usage of the Moore-Penrose pseudoinverse yield a least square solution of the problem at hand.  <a href="classHierarchicalOptimizationControl.html#aa5be7152ab8fe0eb6dcb595aa5d961b5">More...</a><br /></td></tr>
<tr class="separator:aa5be7152ab8fe0eb6dcb595aa5d961b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433baff8381df342f76d459a0cbc8e22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a433baff8381df342f76d459a0cbc8e22">SolveQP</a> (const Eigen::MatrixXd &amp;_Q, const Eigen::VectorXd &amp;_c, const Eigen::MatrixXd &amp;_E_ineq, const Eigen::VectorXd &amp;_f_ineq, Eigen::VectorXd &amp;_sol, const <a class="el" href="classHierarchicalOptimizationControl.html#ae49f08ceaee8df6933d8708fb68c3b99">SolverType</a> &amp;_solver=SolverType::UNSPECIFIED, const int &amp;_v=0)</td></tr>
<tr class="memdesc:a433baff8381df342f76d459a0cbc8e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SolveQP function solves a (convex) quadratic program (QP) on the form:  <a href="classHierarchicalOptimizationControl.html#a433baff8381df342f76d459a0cbc8e22">More...</a><br /></td></tr>
<tr class="separator:a433baff8381df342f76d459a0cbc8e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9f5c00bddda83d936b7e8fd9a866c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a7c9f5c00bddda83d936b7e8fd9a866c1">SolveQP</a> (const Eigen::MatrixXd &amp;_Q, const Eigen::VectorXd &amp;_c, const Eigen::MatrixXd &amp;_A, const Eigen::VectorXd &amp;_lb, const Eigen::VectorXd &amp;_ub, Eigen::VectorXd &amp;_sol, const <a class="el" href="classHierarchicalOptimizationControl.html#ae49f08ceaee8df6933d8708fb68c3b99">SolverType</a> &amp;_solver=SolverType::UNSPECIFIED, const int &amp;_v=0)</td></tr>
<tr class="memdesc:a7c9f5c00bddda83d936b7e8fd9a866c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SolveQP function solves a (convex) quadratic program (QP) on the form:  <a href="classHierarchicalOptimizationControl.html#a7c9f5c00bddda83d936b7e8fd9a866c1">More...</a><br /></td></tr>
<tr class="separator:a7c9f5c00bddda83d936b7e8fd9a866c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11873bac4d3825be997c4f2401c62b7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a11873bac4d3825be997c4f2401c62b7c">SolveQP</a> (const Eigen::MatrixXd &amp;_Q, const Eigen::VectorXd &amp;_c, const Eigen::MatrixXd &amp;_E_eq, const Eigen::VectorXd &amp;_f_eq, const Eigen::MatrixXd &amp;_E_ineq, const Eigen::VectorXd &amp;_f_ineq, Eigen::VectorXd &amp;_sol, const <a class="el" href="classHierarchicalOptimizationControl.html#ae49f08ceaee8df6933d8708fb68c3b99">SolverType</a> &amp;_solver=SolverType::UNSPECIFIED, const int &amp;_v=0)</td></tr>
<tr class="memdesc:a11873bac4d3825be997c4f2401c62b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The SolveQP function solves a (convex) quadratic program (QP) on the form:  <a href="classHierarchicalOptimizationControl.html#a11873bac4d3825be997c4f2401c62b7c">More...</a><br /></td></tr>
<tr class="separator:a11873bac4d3825be997c4f2401c62b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b10d0ecf2dd9c9fbed0864913e5f1f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a4b10d0ecf2dd9c9fbed0864913e5f1f7">PublishTorqueMsg</a> (const Eigen::Matrix&lt; double, 12, 1 &gt; &amp;_desired_tau)</td></tr>
<tr class="memdesc:a4b10d0ecf2dd9c9fbed0864913e5f1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The PublishTorqueMsg function publishes a desired torque message to the ROS topic set by the joint state publisher.  <a href="classHierarchicalOptimizationControl.html#a4b10d0ecf2dd9c9fbed0864913e5f1f7">More...</a><br /></td></tr>
<tr class="separator:a4b10d0ecf2dd9c9fbed0864913e5f1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74787630f85dd651a6bd25463c77011d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a74787630f85dd651a6bd25463c77011d">OnGenCoordMsg</a> (const std_msgs::Float64MultiArrayConstPtr &amp;_msg)</td></tr>
<tr class="memdesc:a74787630f85dd651a6bd25463c77011d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OnGenCoordMsg function handles an incoming generalized coordinates message from ROS.  <a href="classHierarchicalOptimizationControl.html#a74787630f85dd651a6bd25463c77011d">More...</a><br /></td></tr>
<tr class="separator:a74787630f85dd651a6bd25463c77011d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93711c61e175c11b2a87d72b62ce335"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#ac93711c61e175c11b2a87d72b62ce335">OnGenVelMsg</a> (const std_msgs::Float64MultiArrayConstPtr &amp;_msg)</td></tr>
<tr class="memdesc:ac93711c61e175c11b2a87d72b62ce335"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OnGenVelMsg function handles an incoming generalized velocities message from ROS.  <a href="classHierarchicalOptimizationControl.html#ac93711c61e175c11b2a87d72b62ce335">More...</a><br /></td></tr>
<tr class="separator:ac93711c61e175c11b2a87d72b62ce335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b447e6598894c0201069eed1824d6e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a9b447e6598894c0201069eed1824d6e0">OnContactStateMsg</a> (const std_msgs::Int8MultiArrayConstPtr &amp;_msg)</td></tr>
<tr class="memdesc:a9b447e6598894c0201069eed1824d6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OnContactStateMsg function handles an incoming contact state message from ROS.  <a href="classHierarchicalOptimizationControl.html#a9b447e6598894c0201069eed1824d6e0">More...</a><br /></td></tr>
<tr class="separator:a9b447e6598894c0201069eed1824d6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4d34cb22c8051aec0783d46cc4ac3e"><td class="memItemLeft" align="right" valign="top"><a id="a6e4d34cb22c8051aec0783d46cc4ac3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a6e4d34cb22c8051aec0783d46cc4ac3e">ProcessQueueThread</a> ()</td></tr>
<tr class="memdesc:a6e4d34cb22c8051aec0783d46cc4ac3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ProcessQueueThread function is a ROS helper function that processes messages. <br /></td></tr>
<tr class="separator:a6e4d34cb22c8051aec0783d46cc4ac3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d93520a2d70e8e8be5e5a43c1ce1029"><td class="memItemLeft" align="right" valign="top"><a id="a9d93520a2d70e8e8be5e5a43c1ce1029"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a9d93520a2d70e8e8be5e5a43c1ce1029">PublishQueueThread</a> ()</td></tr>
<tr class="memdesc:a9d93520a2d70e8e8be5e5a43c1ce1029"><td class="mdescLeft">&#160;</td><td class="mdescRight">The PublishQueueThread function is a ROS helper function that publish state messages. <br /></td></tr>
<tr class="separator:a9d93520a2d70e8e8be5e5a43c1ce1029"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3ebddce797dad8acbc82ea07153a152a"><td class="memItemLeft" align="right" valign="top"><a id="a3ebddce797dad8acbc82ea07153a152a"></a>
<a class="el" href="classKinematics.html">Kinematics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a3ebddce797dad8acbc82ea07153a152a">kinematics</a></td></tr>
<tr class="memdesc:a3ebddce797dad8acbc82ea07153a152a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classKinematics.html" title="A class for analytical Kinematics Solving.">Kinematics</a>. <br /></td></tr>
<tr class="separator:a3ebddce797dad8acbc82ea07153a152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aba710ef1d1286a31e3425ff59b32531f"><td class="memItemLeft" align="right" valign="top"><a id="aba710ef1d1286a31e3425ff59b32531f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#aba710ef1d1286a31e3425ff59b32531f">InitRos</a> ()</td></tr>
<tr class="memdesc:aba710ef1d1286a31e3425ff59b32531f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The InitRos function is called to initialize ROS. <br /></td></tr>
<tr class="separator:aba710ef1d1286a31e3425ff59b32531f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d211069a2986afc30972841b720636f"><td class="memItemLeft" align="right" valign="top"><a id="a8d211069a2986afc30972841b720636f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a8d211069a2986afc30972841b720636f">InitRosQueueThreads</a> ()</td></tr>
<tr class="memdesc:a8d211069a2986afc30972841b720636f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The InitRosQueueThreads function is called to initialize the ROS Publish and Process Queue Threads. <br /></td></tr>
<tr class="separator:a8d211069a2986afc30972841b720636f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3e23b5a0fbcba631770e756119b280f3"><td class="memItemLeft" align="right" valign="top"><a id="a3e23b5a0fbcba631770e756119b280f3"></a>
Eigen::Matrix&lt; double, 18, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a3e23b5a0fbcba631770e756119b280f3">genCoord</a></td></tr>
<tr class="memdesc:a3e23b5a0fbcba631770e756119b280f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized Coordinates. <br /></td></tr>
<tr class="separator:a3e23b5a0fbcba631770e756119b280f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e467b6f16a7386738c630ffecfde7eb"><td class="memItemLeft" align="right" valign="top"><a id="a6e467b6f16a7386738c630ffecfde7eb"></a>
Eigen::Matrix&lt; double, 18, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a6e467b6f16a7386738c630ffecfde7eb">genVel</a></td></tr>
<tr class="memdesc:a6e467b6f16a7386738c630ffecfde7eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized Velocities. <br /></td></tr>
<tr class="separator:a6e467b6f16a7386738c630ffecfde7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c549f1c59ab0ce611c7cb5263bad484"><td class="memItemLeft" align="right" valign="top"><a id="a9c549f1c59ab0ce611c7cb5263bad484"></a>
Eigen::Matrix&lt; Eigen::Vector3d, 4, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a9c549f1c59ab0ce611c7cb5263bad484">fPos</a></td></tr>
<tr class="memdesc:a9c549f1c59ab0ce611c7cb5263bad484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Foot-point positions. <br /></td></tr>
<tr class="separator:a9c549f1c59ab0ce611c7cb5263bad484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826091dcae900863dc889d6a08b28c7a"><td class="memItemLeft" align="right" valign="top"><a id="a826091dcae900863dc889d6a08b28c7a"></a>
Eigen::Matrix&lt; Eigen::Vector3d, 4, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a826091dcae900863dc889d6a08b28c7a">fVel</a></td></tr>
<tr class="memdesc:a826091dcae900863dc889d6a08b28c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Foot-point velocities. <br /></td></tr>
<tr class="separator:a826091dcae900863dc889d6a08b28c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57508e54f2fc8141e85b42fe37258b26"><td class="memItemLeft" align="right" valign="top"><a id="a57508e54f2fc8141e85b42fe37258b26"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a57508e54f2fc8141e85b42fe37258b26">contactState</a> [4]</td></tr>
<tr class="memdesc:a57508e54f2fc8141e85b42fe37258b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contact State. <br /></td></tr>
<tr class="separator:a57508e54f2fc8141e85b42fe37258b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ef49eb41136313bf06f1cceb8d418d"><td class="memItemLeft" align="right" valign="top"><a id="a24ef49eb41136313bf06f1cceb8d418d"></a>
std::unique_ptr&lt; ros::NodeHandle &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a24ef49eb41136313bf06f1cceb8d418d">rosNode</a></td></tr>
<tr class="memdesc:a24ef49eb41136313bf06f1cceb8d418d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node used for ROS transport. <br /></td></tr>
<tr class="separator:a24ef49eb41136313bf06f1cceb8d418d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe12683785864cacf2010c6e9a6936e"><td class="memItemLeft" align="right" valign="top"><a id="acbe12683785864cacf2010c6e9a6936e"></a>
ros::Subscriber&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#acbe12683785864cacf2010c6e9a6936e">genCoordSub</a></td></tr>
<tr class="memdesc:acbe12683785864cacf2010c6e9a6936e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ROS Generalized Coordinates Subscriber. <br /></td></tr>
<tr class="separator:acbe12683785864cacf2010c6e9a6936e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aaae9d1fd83d092f74b3b43f28ba89f"><td class="memItemLeft" align="right" valign="top"><a id="a1aaae9d1fd83d092f74b3b43f28ba89f"></a>
ros::Subscriber&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a1aaae9d1fd83d092f74b3b43f28ba89f">genVelSub</a></td></tr>
<tr class="memdesc:a1aaae9d1fd83d092f74b3b43f28ba89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ROS Generalized Coordinates Subscriber. <br /></td></tr>
<tr class="separator:a1aaae9d1fd83d092f74b3b43f28ba89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96f07a84d44b9ef83e0a2743748d396"><td class="memItemLeft" align="right" valign="top"><a id="ae96f07a84d44b9ef83e0a2743748d396"></a>
ros::Subscriber&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#ae96f07a84d44b9ef83e0a2743748d396">contactStateSub</a></td></tr>
<tr class="memdesc:ae96f07a84d44b9ef83e0a2743748d396"><td class="mdescLeft">&#160;</td><td class="mdescRight">ROS Contact State Subscriber. <br /></td></tr>
<tr class="separator:ae96f07a84d44b9ef83e0a2743748d396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a139ccf51e5752acb6444ba5538012"><td class="memItemLeft" align="right" valign="top"><a id="aa2a139ccf51e5752acb6444ba5538012"></a>
ros::Publisher&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#aa2a139ccf51e5752acb6444ba5538012">jointStatePub</a></td></tr>
<tr class="memdesc:aa2a139ccf51e5752acb6444ba5538012"><td class="mdescLeft">&#160;</td><td class="mdescRight">ROS Joint State Publisher. <br /></td></tr>
<tr class="separator:aa2a139ccf51e5752acb6444ba5538012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682c7813dae3fb5095471020aeacb66c"><td class="memItemLeft" align="right" valign="top"><a id="a682c7813dae3fb5095471020aeacb66c"></a>
ros::CallbackQueue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a682c7813dae3fb5095471020aeacb66c">rosProcessQueue</a></td></tr>
<tr class="memdesc:a682c7813dae3fb5095471020aeacb66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ROS callbackque that helps process messages. <br /></td></tr>
<tr class="separator:a682c7813dae3fb5095471020aeacb66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b6a8d56a87ee082fc449b1a04696c6"><td class="memItemLeft" align="right" valign="top"><a id="ad0b6a8d56a87ee082fc449b1a04696c6"></a>
ros::CallbackQueue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#ad0b6a8d56a87ee082fc449b1a04696c6">rosPublishQueue</a></td></tr>
<tr class="memdesc:ad0b6a8d56a87ee082fc449b1a04696c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ROS callbackque that helps publish messages. <br /></td></tr>
<tr class="separator:ad0b6a8d56a87ee082fc449b1a04696c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9716a46806a970fc21a6430ec7a336"><td class="memItemLeft" align="right" valign="top"><a id="a1c9716a46806a970fc21a6430ec7a336"></a>
std::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a1c9716a46806a970fc21a6430ec7a336">rosProcessQueueThread</a></td></tr>
<tr class="memdesc:a1c9716a46806a970fc21a6430ec7a336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread running the rosProcessQueue. <br /></td></tr>
<tr class="separator:a1c9716a46806a970fc21a6430ec7a336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277b358c6f3136f50c5bf3a3122112d7"><td class="memItemLeft" align="right" valign="top"><a id="a277b358c6f3136f50c5bf3a3122112d7"></a>
std::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHierarchicalOptimizationControl.html#a277b358c6f3136f50c5bf3a3122112d7">rosPublishQueueThread</a></td></tr>
<tr class="memdesc:a277b358c6f3136f50c5bf3a3122112d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread running the rosPublishQueue. <br /></td></tr>
<tr class="separator:a277b358c6f3136f50c5bf3a3122112d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for hierarchical optimization control. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a911cef032be8319e4ed16b0a26dd8804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911cef032be8319e4ed16b0a26dd8804">&#9670;&nbsp;</a></span>HierarchicalOptimization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; double, 12, 1 &gt; HierarchicalOptimizationControl::HierarchicalOptimization </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_desired_base_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_desired_base_vel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_desired_base_acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_desired_base_ori</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Eigen::Vector3d, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_desired_f_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Eigen::Vector3d, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_desired_f_vel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Eigen::Vector3d, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_desired_f_acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Eigen::Vector3d, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_f_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Eigen::Vector3d, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_f_vel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 18, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 18, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>_v</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The HierarchicalOptimization function finds the optimal joint torques for a desired motion plan. It finds joint torques by finding optimal joint accelerations and contact forces for a set of whole-body control QP tasks, and leveraging inverse dynamics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_desired_base_pos</td><td>Desired base position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_desired_base_vel</td><td>Desired base velocity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_desired_base_acc</td><td>Desired base acceleration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_desired_base_ori</td><td>Desired base orientation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_desired_f_pos</td><td>Desired foot-point positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_desired_f_vel</td><td>Desired foot-point velocities. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_desired_f_acc</td><td>Desired foot-point accelerations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_f_pos</td><td>Foot-point positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_f_vel</td><td>Foot-point velocities. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_v</td><td>Verbosity level [0,1,2,3]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the optimal set of joint torques for the whole-body control problem leveraging hierarchical optimization. <br  />
 </dd></dl>

</div>
</div>
<a id="a64f7ef31eba78810a479bc70ecd26543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f7ef31eba78810a479bc70ecd26543">&#9670;&nbsp;</a></span>HierarchicalQPOptimization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; HierarchicalOptimizationControl::HierarchicalQPOptimization </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>_state_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structHierarchicalOptimizationControl_1_1Task.html">Task</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_tasks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHierarchicalOptimizationControl.html#ae49f08ceaee8df6933d8708fb68c3b99">SolverType</a> &amp;&#160;</td>
          <td class="paramname"><em>_solver</em> = <code>SolverType::OSQP</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>_v</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The HierarchicalQPOptimization function finds the optimal solution for a set of tasks in a strictly prioritized order. The method iterates through the set of tasks and searches for a new solution in the null-space of all higher priority equality constraints. At each iteration a QP problem is solved to find a vector lying in the row-space of the null-space of all equality constraints, which improve on the current solution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_state_dim</td><td>State dimension for the solution vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_tasks</td><td>A set of tasks to be solved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_solver</td><td>Solver type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_v</td><td>Verbosity level [0,1,2,3]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the optimal solution in a strict prioritized manner given a set of tasks. <br  />
 </dd></dl>

</div>
</div>
<a id="aa5be7152ab8fe0eb6dcb595aa5d961b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5be7152ab8fe0eb6dcb595aa5d961b5">&#9670;&nbsp;</a></span>HierarchicalLeastSquareOptimization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; HierarchicalOptimizationControl::HierarchicalLeastSquareOptimization </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Eigen::MatrixXd, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>_v</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The HierarchicalLeastSquareOptimization function finds the optimal solution for a set of linear equality constraints in a strictly prioritized order. The method iterates through the set of equality constraints and searches for a new solution in the null-space of all higher priority equality constraints. At each iteration the Moore-Penrose pseudoinverse is utilized to find a vector lying in the row-space of the null-space of all equality constraints, which improve on the current solution. The usage of the Moore-Penrose pseudoinverse yield a least square solution of the problem at hand. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_A</td><td>A set of equality constraint matrices A. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_b</td><td>A set of equality constraint vectors b. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_v</td><td>Verbosity level [0,1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the optimal solution in a strict prioritized manner given a set of equality constraints. </dd></dl>

</div>
</div>
<a id="a433baff8381df342f76d459a0cbc8e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433baff8381df342f76d459a0cbc8e22">&#9670;&nbsp;</a></span>SolveQP() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HierarchicalOptimizationControl::SolveQP </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>_Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>_E_ineq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>_f_ineq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>_sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHierarchicalOptimizationControl.html#ae49f08ceaee8df6933d8708fb68c3b99">SolverType</a> &amp;&#160;</td>
          <td class="paramname"><em>_solver</em> = <code>SolverType::UNSPECIFIED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>_v</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SolveQP function solves a (convex) quadratic program (QP) on the form: </p>
<pre class="fragment">min_x        0.5 x^T Q x + c^T x
 s.t.        E_ineq x &lt;= f_ineq
</pre><p>The toolbox uses the Drake toolbox for solving the problem. Currently Drake identifies the problem and chooses an appropriate commercial solver, but the solver can be specified (among the supported) by the user if one desires. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_Q</td><td>Cost matrix Q (must be positive semidefinite). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_c</td><td>Cost vector c. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_E_ineq</td><td>Linear inequality constraint matrix E_ineq; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_f_ineq</td><td>Linear inequality constraint vector f_ineq; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_sol</td><td>Solution of the QP (if it exists). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_solver</td><td>Solver type, default is unspecified (Drake will choose accordingly). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_v</td><td>Verbosity level. // TODO Update after verbosity is set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if a solution is found, false if not. </dd></dl>

</div>
</div>
<a id="a7c9f5c00bddda83d936b7e8fd9a866c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9f5c00bddda83d936b7e8fd9a866c1">&#9670;&nbsp;</a></span>SolveQP() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HierarchicalOptimizationControl::SolveQP </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>_Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>_lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>_ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>_sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHierarchicalOptimizationControl.html#ae49f08ceaee8df6933d8708fb68c3b99">SolverType</a> &amp;&#160;</td>
          <td class="paramname"><em>_solver</em> = <code>SolverType::UNSPECIFIED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>_v</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SolveQP function solves a (convex) quadratic program (QP) on the form: </p>
<pre class="fragment">min_x        0.5 x^T Q x + c^T x
 s.t.        lb &lt;= A x &lt;= ub        
</pre><p>The toolbox uses the Drake toolbox for solving the problem. Currently Drake identifies the problem and chooses an appropriate commercial solver, but the solver can be specified (among the supported) by the user if one desires. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_Q</td><td>Cost matrix Q (must be positive semidefinite). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_c</td><td>Cost vector c. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_A</td><td>Linear inequality constraint matrix A; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_lb</td><td>Linear inequality constraint lower bound vector; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_ub</td><td>Linear inequality constraint upper bound vector; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_sol</td><td>Solution of the QP (if it exists). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_solver</td><td>Solver type, default is unspecified (Drake will choose accordingly). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_v</td><td>Verbosity level. // TODO Update after verbosity is set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if a solution is found, false if not. </dd></dl>

</div>
</div>
<a id="a11873bac4d3825be997c4f2401c62b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11873bac4d3825be997c4f2401c62b7c">&#9670;&nbsp;</a></span>SolveQP() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HierarchicalOptimizationControl::SolveQP </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>_Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>_E_eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>_f_eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>_E_ineq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>_f_ineq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>_sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classHierarchicalOptimizationControl.html#ae49f08ceaee8df6933d8708fb68c3b99">SolverType</a> &amp;&#160;</td>
          <td class="paramname"><em>_solver</em> = <code>SolverType::UNSPECIFIED</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>_v</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The SolveQP function solves a (convex) quadratic program (QP) on the form: </p>
<pre class="fragment">min_x        0.5 x^T Q x + c^T x
 s.t.          E_eq x  = f_eq
             E_ineq x &lt;= f_ineq
</pre><p>The toolbox uses the Drake toolbox for solving the problem. Currently Drake identifies the problem and chooses an appropriate commercial solver, but the solver can be specified (among the supported) by the user if one desires. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_Q</td><td>Cost matrix Q (must be positive semidefinite). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_c</td><td>Cost vector c. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_E_eq</td><td>Linear equality constraint matrix E_eq; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_f_eq</td><td>Linear equality constraint vector f_eq; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_E_ineq</td><td>Linear inequality constraint matrix E_ineq; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_f_ineq</td><td>Linear inequality constraint vector f_ineq; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_sol</td><td>Solution of the QP (if it exists). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_solver</td><td>Solver type, default is unspecified (Drake will choose accordingly). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_v</td><td>Verbosity level. // TODO Update after verbosity is set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if a solution is found, false if not. </dd></dl>

</div>
</div>
<a id="a4b10d0ecf2dd9c9fbed0864913e5f1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b10d0ecf2dd9c9fbed0864913e5f1f7">&#9670;&nbsp;</a></span>PublishTorqueMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HierarchicalOptimizationControl::PublishTorqueMsg </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 12, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>_desired_tau</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The PublishTorqueMsg function publishes a desired torque message to the ROS topic set by the joint state publisher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_desired_tau</td><td>Desired torque to be published. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74787630f85dd651a6bd25463c77011d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74787630f85dd651a6bd25463c77011d">&#9670;&nbsp;</a></span>OnGenCoordMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HierarchicalOptimizationControl::OnGenCoordMsg </td>
          <td>(</td>
          <td class="paramtype">const std_msgs::Float64MultiArrayConstPtr &amp;&#160;</td>
          <td class="paramname"><em>_msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The OnGenCoordMsg function handles an incoming generalized coordinates message from ROS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_msg</td><td>A float array containing the generalized coordinates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac93711c61e175c11b2a87d72b62ce335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93711c61e175c11b2a87d72b62ce335">&#9670;&nbsp;</a></span>OnGenVelMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HierarchicalOptimizationControl::OnGenVelMsg </td>
          <td>(</td>
          <td class="paramtype">const std_msgs::Float64MultiArrayConstPtr &amp;&#160;</td>
          <td class="paramname"><em>_msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The OnGenVelMsg function handles an incoming generalized velocities message from ROS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_msg</td><td>A float array containing the generalized velocities. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b447e6598894c0201069eed1824d6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b447e6598894c0201069eed1824d6e0">&#9670;&nbsp;</a></span>OnContactStateMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HierarchicalOptimizationControl::OnContactStateMsg </td>
          <td>(</td>
          <td class="paramtype">const std_msgs::Int8MultiArrayConstPtr &amp;&#160;</td>
          <td class="paramname"><em>_msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The OnContactStateMsg function handles an incoming contact state message from ROS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_msg</td><td>A float array containing the contact state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>catkin_ws/src/control/hierarchical_optimization_controller/include/hierarchical_optimization_controller/<a class="el" href="hierarchical__optimization__controller_8h_source.html">hierarchical_optimization_controller.h</a></li>
<li>catkin_ws/src/control/hierarchical_optimization_controller/src/hierarchical_optimization_controller.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
