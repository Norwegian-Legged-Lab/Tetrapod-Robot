Check the \href{cheatsheet_latest.pdf}{\texttt{ {\bfseries{cheatsheet}}}} to understand the math behind.\hypertarget{page_users_orientation_pose}{}\doxysection{Rotations and Poses}\label{page_users_orientation_pose}

\begin{DoxyItemize}
\item \mbox{\hyperlink{page_rotations}{Rotations}}
\item \mbox{\hyperlink{page_poses}{Poses}}
\end{DoxyItemize}\hypertarget{page_users_velocities}{}\doxysection{Time Derivatives of Rotations and Poses}\label{page_users_velocities}

\begin{DoxyItemize}
\item \mbox{\hyperlink{page_rdiff}{Time Derivatives of Rotations}}
\item \mbox{\hyperlink{page_posesdiff}{Time Derivatives of Poses}}
\end{DoxyItemize}\hypertarget{page_users_misc}{}\doxysection{Mathematical Tools}\label{page_users_misc}

\begin{DoxyItemize}
\item \mbox{\hyperlink{page_quaternion}{Quaternions}}
\end{DoxyItemize}\hypertarget{page_users_vectors}{}\doxysection{Vectors}\label{page_users_vectors}

\begin{DoxyItemize}
\item \mbox{\hyperlink{page_vector}{Vectors}} 
\end{DoxyItemize}\hypertarget{page_rotations}{}\doxysection{Rotations}\label{page_rotations}
\hypertarget{page_rotations_rotations_introduction}{}\doxysubsection{Introduction}\label{page_rotations_rotations_introduction}
A rotation between two rigid bodies can be represented by using different parameterizations. The most well-\/known parameterizations are Euler angles, rotation matrix, angle-\/axis, rotation vector and unit quaternion. Depending on the application, some representations may be better suited than others. For instance, a unit quaternion does not have singularity issues like Euler angles and are therefore better suited for calculations, but Euler angles are much easier to be interpreted by a user. The library provides therefore a type for each parameterization of a rotation, which enables type safe conversions between different representations.

The type of a rotation further depends on the usage of a rotation. A rotation can be considered either as an active (alibi) or a passive (alibi) transformation. The following figure visualizes the difference\+: 

The figure shows a rotation about the z-\/axis with an angle $\theta$. If the rotation is considered as active, the (blue) position vector ${}_A \mathbf{r}_{O\,P}$ expressed in frame A is rotated to the (green) position vector ${}_A \mathbf{r}_{O\,Q}$, which is also expressed in frame A. If the rotation is considered as passive, the (blue) vector $ {}_A \mathbf{ r}_{O\,P}$ is not rotated actively, but its coordinates are mapped from frame A to frame B, i.\+e. the result is ${}_B \mathbf{r}_{O\,P}$. In other words, an active rotation rotates a vector, whereas a passive rotation rotates the coordinate frame. The result of rotation applied to a vector or column-\/wise to a matrix therefore depends on the usage type.

This library provides a passive implementation of different rotation parameterizations. The library depends on the \href{http://eigen.tuxfamily.org}{\texttt{ C++ Eigen library}}, which already provides some of the representations, but does not feature the type safety and misses many features.

The following section describes the genric interface of all rotation classes, whereas the section \mbox{\hyperlink{page_rotations_rotations_interfaces_representations}{Parameterizations}} shows the different parameterizations and explains how to use them.\hypertarget{page_rotations_rotations_interfaces}{}\doxysubsection{Generic Interface}\label{page_rotations_rotations_interfaces}
\hypertarget{page_rotations_rotations_interfaces_rotation}{}\doxysubsubsection{Rotation Base Class}\label{page_rotations_rotations_interfaces_rotation}
The class \mbox{\hyperlink{classkindr_1_1RotationBase}{kindr\+::\+Rotation\+Base}} serves as an interface for a rotation between two rigid bodies. All types of representations of a rotation, such as quaternion, angle-\/axis, and Euler angles, are derived from this base class.

The type of a rotation is defined by
\begin{DoxyItemize}
\item the \mbox{\hyperlink{page_rotations_rotations_interfaces_representations}{kind of parameterization}} (angle-\/axis, quaternion, etc.) and
\item the primitive data type of the parameters (float/double, etc.).
\end{DoxyItemize}\hypertarget{page_rotations_rotations_interfaces_rotation_constructor}{}\doxysubsubsection{Construction of a Rotation}\label{page_rotations_rotations_interfaces_rotation_constructor}
The default constructor of a rotation always creates an identity rotation. If the library is built with debugging symbols, an assertion is thrown if a rotation is constructed with parameter values that do not represent a valid rotation.\hypertarget{page_rotations_rotations_interfaces_rotation_identity}{}\doxysubsubsection{Identity Rotation}\label{page_rotations_rotations_interfaces_rotation_identity}
Any rotation can be set equal to the identity rotation by the method \mbox{\hyperlink{classkindr_1_1RotationBase_aad3997140e6950ccc93e7be822959e2e}{set\+Identity()}}.\hypertarget{page_rotations_rotations_interfaces_rotation_fromVectors}{}\doxysubsubsection{Rotation from Two Vectors}\label{page_rotations_rotations_interfaces_rotation_fromVectors}
A rotation that describes the relative orientation of two vectors can be initialized by means of the method \mbox{\hyperlink{classkindr_1_1RotationBase_a31d35d5050c98630adc1895216e47a3b}{set\+From\+Vectors()}}. \hypertarget{page_rotations_rotations_interfaces_rotation_unique}{}\doxyparagraph{Unique Rotation}\label{page_rotations_rotations_interfaces_rotation_unique}
A rotation can be represented in different ways. The quaternion $Q = q_0 + q_1 i + q_2 j + q_3 k$ and the quaternion $Q = -q_0 - q_1 i - q_2 j - q_3 k$, for instance, represent the same rotation. However, sometimes a unique representation is desired.

A unique representation is obtained by
\begin{DoxyItemize}
\item \mbox{\hyperlink{classkindr_1_1RotationBase_a3b6393e323287c998bc6c567c10c80c3}{get\+Unique()}}\+: gets a copy of the presentation, which is unique, and
\item \mbox{\hyperlink{classkindr_1_1RotationBase_a1f292f64472c281db756012b632707df}{set\+Unique()}}\+: sets the representation to the unique representation.
\end{DoxyItemize}

Note that numerical issues may cause problems when this method is used to compare two rotations. We therefore recommend to use the method \mbox{\hyperlink{classkindr_1_1RotationBase_ad674b4668d1a171b5efa7df9ba25b38f}{is\+Near()}} (see below).\hypertarget{page_rotations_rotations_interfaces_rotation_inverse}{}\doxysubsubsection{Inverse of a Rotation}\label{page_rotations_rotations_interfaces_rotation_inverse}
The inverse of a rotation is provided by two methods\+:
\begin{DoxyItemize}
\item \mbox{\hyperlink{classkindr_1_1RotationBase_a8db8faa8dddad01a41699dd926c2420f}{invert()}} returns and stores the inverse
\item \mbox{\hyperlink{classkindr_1_1RotationBase_a1cbe632e37e0a054e2f123d3d0889cf6}{inverted()}} returns only the inverse
\end{DoxyItemize}\hypertarget{page_rotations_rotations_interfaces_rotation_composition}{}\doxysubsubsection{Composition of a Rotation}\label{page_rotations_rotations_interfaces_rotation_composition}
A rotation can be composed of other rotations. The multiplication operator enables to concatenate rotations as follows\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{C\_DA = C\_DC*C\_CB*C\_BA;}
\end{DoxyCode}
 Due to numerical issues, the result of the concatenation may become an invalid rotation. Due to speed considerations, the user is responsible to guarentee that the parameter values represent a valid rotation. The library therefore offers the method \mbox{\hyperlink{classkindr_1_1RotationBase_a0d56418383e3cbad4ddbe3d00553245d}{fix()}} to project the parameters to the admissible space. The method would, for instance, normalize the rotation quaternion.\hypertarget{page_rotations_rotations_interfaces_rotation_rotate}{}\doxysubsubsection{Rotation of a Vector or a Matrix}\label{page_rotations_rotations_interfaces_rotation_rotate}
To rotate a vector or a matrix columnwise, the following methods are provided\+:
\begin{DoxyItemize}
\item \mbox{\hyperlink{classkindr_1_1RotationBase_a0b461d729f66615029629fa37bc69ed3}{rotate()}}\+: rotates a vector or a matrix columnwise
\item \mbox{\hyperlink{classkindr_1_1RotationBase_a558a7f1b1963413c7fee33bde168ef96}{inverse\+Rotate()}}\+: reverse rotates a vector or a matrix columnwise
\end{DoxyItemize}\hypertarget{page_rotations_rotations_interfaces_rotation_exponentialmap}{}\doxysubsubsection{Exponential Map and Logarithmic Map}\label{page_rotations_rotations_interfaces_rotation_exponentialmap}
The exponential map maps a vector in $\mathsf{R}^3$ describing the axis and magnitude of a three degree-\/of-\/freedom rotation to the corresponding rotation parameterization. The mapping is provided by the method \mbox{\hyperlink{classkindr_1_1RotationBase_ab795e76e48ab2474240721ebc49cde6f}{exponential\+Map()}}. The corresponding logarithmic map is provided by the method \mbox{\hyperlink{classkindr_1_1RotationBase_a691cf4b267164a964a462380e324126e}{logarithmic\+Map()}}.\hypertarget{page_rotations_rotations_interfaces_rotation_boxoperations}{}\doxysubsubsection{Box Plus and Box Minus Operations}\label{page_rotations_rotations_interfaces_rotation_boxoperations}
The box plus operation defined as $\mathcal{R}_2 = \mathcal{R}_1\boxplus\mathbf{v} = \mathcal{R}(e^{\hat{\mathbf{v}}}) \cdot \mathcal{R}_1 $, where $\mathcal{R}$ is a rotation, $\mathbf{v}$ is a vector in $\mathsf{R}^3$ and $\hat{}$ maps a vector to the skew-\/symmetric matrix corresponding to the cross product, is provided by the method \mbox{\hyperlink{classkindr_1_1RotationBase_a65c48f330b3f92db8ecf2f2c539265ea}{box\+Plus()}}.

The box minus operation defined as $\mathbf{v} = \mathcal{R}_1\boxminus\mathcal{R}_2 = \ln{(\mathcal{R}_1\cdot\mathcal{R}_2^{-1})}\check{}$ is provided by the method \mbox{\hyperlink{classkindr_1_1RotationBase_a96158c21692da59bce4ae0eb7025802f}{box\+Minus()}}.

\textbackslash{}subection rotations\+\_\+interfaces\+\_\+comparison Comparison of Rotations To compare two rotations, the equal operator (operator==) can be used to check if a rotation is equal to another rotation.

Small numeric errors may however lead to a wrong result. Therefore, the function \mbox{\hyperlink{classkindr_1_1RotationBase_ad674b4668d1a171b5efa7df9ba25b38f}{is\+Near()}} compares two rotations using a measure.

The difference between two rotations can be obtained by the method \mbox{\hyperlink{classkindr_1_1RotationBase_a8a41839de5d7ff9cb702b6c9fceae9b6}{get\+Disparity\+Angle()}}.\hypertarget{page_rotations_rotations_interfaces_conversion}{}\doxysubsubsection{Conversion between Rotations}\label{page_rotations_rotations_interfaces_conversion}
There are two kinds of conversions\+:
\begin{DoxyItemize}
\item Conversion between different representations, i.\+e. between different parameterizations (e.\+g. rotation quaternion -\/ angle-\/axis)
\item Conversion between different primitive data types (e.\+g. float -\/ double)
\end{DoxyItemize}\hypertarget{page_rotations_rotations_interfaces_conversion_representations}{}\doxyparagraph{Conversion between Representations}\label{page_rotations_rotations_interfaces_conversion_representations}
The following methods allow to convert between different representations of a rotation\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{AngleAxisD angleAxis;}
\DoxyCodeLine{RotationQuaternionD quaternion(angleAxis);  \textcolor{comment}{// constructor}}
\DoxyCodeLine{angleAxis = quaternion;             \textcolor{comment}{// assignment operator}}
\DoxyCodeLine{quaternion(angleAxis);              \textcolor{comment}{// parenthesis operator}}
\end{DoxyCode}
\hypertarget{page_rotations_rotations_interfaces_conversion_primtype}{}\doxyparagraph{Conversion between Primitive Data Types}\label{page_rotations_rotations_interfaces_conversion_primtype}
The conversion between different primitive data types (double/float) works the same way as the conversion between different representations.\hypertarget{page_rotations_rotations_interfaces_representations}{}\doxysubsection{Parameterizations}\label{page_rotations_rotations_interfaces_representations}
The following representations are currently provided by the library\+:\hypertarget{page_rotations_rotations_interfaces_angleaxis}{}\doxysubsubsection{Angle-\/\+Axis}\label{page_rotations_rotations_interfaces_angleaxis}
The class \mbox{\hyperlink{classkindr_1_1AngleAxis}{Angle\+Axis}} provides an angle-\/axis representation of a rotation\+:

$\boxed{(\theta, \mathbf{n}), \quad \lVert \mathbf{n} \rVert = 1,}$

where $\theta \in \mathbb{R}$ is the rotation angle and $\mathbf{n} \in \mathbb{R}^3$ is the rotation axis with unit length.

The angle and rotation axis ared stored in Eigen\+::\+Angle\+Axis.

The following typedefs are provided for convenience\+:
\begin{DoxyItemize}
\item Angle\+AxisD for primitive type double
\item Angle\+AxisF for primitive type float
\end{DoxyItemize}\hypertarget{page_rotations_rotations_implementation_angleaxis_create}{}\doxyparagraph{Create an Angle-\/\+Axis}\label{page_rotations_rotations_implementation_angleaxis_create}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double} angle = 0.2;}
\DoxyCodeLine{\textcolor{keywordtype}{double} n\_1 = 1.0;}
\DoxyCodeLine{\textcolor{keywordtype}{double} n\_2 = 0.0;}
\DoxyCodeLine{\textcolor{keywordtype}{double} n\_3 = 0.0;}
\DoxyCodeLine{Eigen::Vector3d axis(n\_1, n\_2, n\_3);}
\DoxyCodeLine{AngleAxisD angleAxis1; \textcolor{comment}{// identity rotation: angle = 0.0 axis = (1.0, 0.0, 0.0)}}
\DoxyCodeLine{AngleAxisD angleAxis2(angle, axis);}
\DoxyCodeLine{AngleAxisD angleAxis3(angle, n\_1, n\_2, n\_3);}
\DoxyCodeLine{AngleAxisD angleAxis4(angle, 1.0, 1.0, 1.0); \textcolor{comment}{// will create an error in debug mode}}
\end{DoxyCode}
\hypertarget{page_rotations_rotations_implementation_angleaxis_use}{}\doxyparagraph{Use an Angle-\/\+Axis}\label{page_rotations_rotations_implementation_angleaxis_use}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double} angle = angleAxis.angle();                                   \textcolor{comment}{// get rotation angle }}
\DoxyCodeLine{Eigen::Vector3d axis = angleAxis.axis();                                \textcolor{comment}{// get rotation axis}}
\DoxyCodeLine{Eigen::AngleAxisd angleAxisEigen = angleAxis.toImplementation();                    \textcolor{comment}{// get Eigen angle-\/axis}}
\DoxyCodeLine{Eigen::Vector3d vector\_rotated = angleAxis.rotate(Eigen::Vector3d(1.0,2.0,3.0));            \textcolor{comment}{// rotate a vector}}
\DoxyCodeLine{Eigen::Vector3d vector\_invrotated = angleAxis.inverseRotate(Eigen::Vector3d(1.0,2.0,3.0));      \textcolor{comment}{// reverse rotate a vector}}
\DoxyCodeLine{angleAxis.setUnique();                                      \textcolor{comment}{// Modifies the angle such that it is in [0,PI)}}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"Angle-\/Axis: "} << angleAxis << std::endl:                      \textcolor{comment}{// output angle-\/axis}}
\DoxyCodeLine{\textcolor{keywordflow}{if} (angleAxis == AngleAxisD(M\_PI/2.0, 1.0, 0.0, 0.0))                           \textcolor{comment}{// compare angle-\/axis}}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"Rotation is about x-\/axis with angle M\_PI/2.0\(\backslash\)n"}; }
\end{DoxyCode}
\hypertarget{page_rotations_rotations_interfaces_rotationvector}{}\doxysubsubsection{Rotation Vector}\label{page_rotations_rotations_interfaces_rotationvector}
The class \mbox{\hyperlink{classkindr_1_1RotationVector}{kindr\+::\+Rotation\+Vector}} implements a rotation vector representation of a rotation\+:

$\boxed{\mathbf{\phi}\in\mathbb{R}^3}$

where $\lVert \mathbf{\phi} \rVert $ is the rotation angle and $\frac{\mathbf{\phi}}{\lVert \mathbf{\phi} \rVert}$ is the rotation axis.

It stores the rotation vector in Eigen\+::\+Matrix$<$\+Scalar, 3, 1$>$.

The following typedefs are provided for convenience\+:
\begin{DoxyItemize}
\item Rotation\+VectorD for primitive type double
\item Rotation\+VectorF for primitive type float
\end{DoxyItemize}\hypertarget{page_rotations_rotations_implementation_rotationvector_create}{}\doxyparagraph{Create a Rotation Vector}\label{page_rotations_rotations_implementation_rotationvector_create}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double} v\_1 = 2.0;}
\DoxyCodeLine{\textcolor{keywordtype}{double} v\_2 = 0.0;}
\DoxyCodeLine{\textcolor{keywordtype}{double} v\_3 = 0.0;}
\DoxyCodeLine{Eigen::Vector3d vector(v\_1, v\_2, v\_3);}
\DoxyCodeLine{RotationVectorD rotationVector1; \textcolor{comment}{// identity rotation: vector = (0.0, 0.0, 0.0)}}
\DoxyCodeLine{RotationVectorD rotationVector2(vector);}
\DoxyCodeLine{RotationVectorD rotationVector3(v\_1, v\_2, v\_3);}
\end{DoxyCode}
\hypertarget{page_rotations_rotations_implementation_rotationvector_use}{}\doxyparagraph{Use a Rotation Vector}\label{page_rotations_rotations_implementation_rotationvector_use}

\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::Vector3d vector = rotationVector.vector();                               \textcolor{comment}{// get Eigen vector}}
\DoxyCodeLine{Eigen::Vector3d vector\_rotated = rotationVector.rotate(Eigen::Vector3d(1.0,2.0,3.0));           \textcolor{comment}{// rotate a vector}}
\DoxyCodeLine{Eigen::Vector3d vector\_invrotated = rotationVector.inverseRotate(Eigen::Vector3d(1.0,2.0,3.0));     \textcolor{comment}{// reverse rotate a vector}}
\DoxyCodeLine{rotationVector.setUnique();                                         \textcolor{comment}{// Modifies the angle such that it is in [0,PI)}}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"Rotation Vector: "} << rotationVector << std::endl:                        \textcolor{comment}{// output angle-\/axis}}
\DoxyCodeLine{\textcolor{keywordflow}{if} (rotationVector == RotationVectorD(M\_PI/2.0, 0.0, 0.0))                          \textcolor{comment}{// compare rotation vector}}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"Rotation is about x-\/axis with angle M\_PI/2.0\(\backslash\)n"}; }
\end{DoxyCode}
\hypertarget{page_rotations_rotations_interfaces_quaternion}{}\doxysubsubsection{Rotation Quaternion}\label{page_rotations_rotations_interfaces_quaternion}
The class \mbox{\hyperlink{classkindr_1_1RotationQuaternion}{kindr\+::\+Rotation\+Quaternion}} implements a Hamiltonian unit quaternion representation of a rotation\+:

$\boxed{\begin{aligned}Q &= q_0 + q_1 i + q_2 j + q_3 k \in \mathbb{H}, \quad q_i \in \mathbb{R} \\ i^2 &= j^2=k^2 = ijk = -1, \quad \lVert Q \rVert= \sqrt{q_0^2 + q_1^2 + q_2^2 + q_3^2} = 1 \\ \end{aligned}}$

It stores the coefficients according to the \mbox{\hyperlink{classkindr_1_1UnitQuaternion}{kindr\+::\+Unit\+Quaternion}}. See also Chapter Quternions for more information.

The following typedefs are provided for convenience\+:
\begin{DoxyItemize}
\item Rotation\+QuaternionD for primitive type double
\item Rotation\+QuaternionF for primitive type float
\end{DoxyItemize}\hypertarget{page_rotations_rotations_implementation_quaternion_create}{}\doxyparagraph{Create a Rotation Quaternion}\label{page_rotations_rotations_implementation_quaternion_create}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double} p\_0 = 1.0;}
\DoxyCodeLine{\textcolor{keywordtype}{double} p\_1 = 0.0;}
\DoxyCodeLine{\textcolor{keywordtype}{double} p\_2 = 0.0;}
\DoxyCodeLine{\textcolor{keywordtype}{double} p\_3 = 0.0;}
\DoxyCodeLine{RotationQuaternionD rquat1;                                 \textcolor{comment}{// identity rotation: (1.0, 0.0, 0.0, 0.0)}}
\DoxyCodeLine{RotationQuaternionD rquat2(p\_0, p\_1, p\_2, p\_3);                 \textcolor{comment}{// create with four scalars}}
\DoxyCodeLine{RotationQuaternionD rquat3(Eigen::Quaterniond(p\_0, p\_1, p\_2, p\_3));         \textcolor{comment}{// create with Eigen quaternion}}
\DoxyCodeLine{RotationQuaternionD rquat5(UnitQuaternion(p\_0, p\_1, p\_2, p\_3));         \textcolor{comment}{// create with unit quaternion}}
\DoxyCodeLine{RotationQuaternionD rquat5(Quaternion(p\_0, p\_1, p\_2, p\_3));         \textcolor{comment}{// create with quaternion}}
\DoxyCodeLine{RotationQuaternionD rquat4(1.0, 1.0, 1.0, 1.0);                     \textcolor{comment}{// will create an error in debug mode}}
\end{DoxyCode}
\hypertarget{page_rotations_rotations_implementation_quaternion_use}{}\doxyparagraph{Use a Quaternion}\label{page_rotations_rotations_implementation_quaternion_use}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double} p\_0 = rquat.w();                                   }
\DoxyCodeLine{\textcolor{keywordtype}{double} p\_1 = rquat.x();}
\DoxyCodeLine{\textcolor{keywordtype}{double} p\_2 = rquat.y();}
\DoxyCodeLine{\textcolor{keywordtype}{double} p\_3 = rquat.z();}
\DoxyCodeLine{Eigen::Quaterniond quatEigen = rquat.toImplementation();                      \textcolor{comment}{// get Eigen quaternion}}
\DoxyCodeLine{UnitQuaternionD uquat = rquat.toUnitQuaternion();                         \textcolor{comment}{// get unit quaternion}}
\DoxyCodeLine{Eigen::Vector3d vector\_rotated = rquat.rotate(Eigen::Vector3d(1.0,2.0,3.0));              \textcolor{comment}{// rotate a vector}}
\DoxyCodeLine{Eigen::Vector3d vector\_invrotated = rquat.inverseRotate(Eigen::Vector3d(1.0,2.0,3.0));        \textcolor{comment}{// reverse rotate a vector}}
\DoxyCodeLine{rquat.setUnique();                                            \textcolor{comment}{// Modifies the quaternion such that p\_0 >= 0}}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"Quaternion: "} << rquat << std::endl:                            \textcolor{comment}{// output quaternion}}
\DoxyCodeLine{\textcolor{keywordflow}{if} (rquat == RotationQuaternionD())                                   \textcolor{comment}{// compare }}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"Rotation is identity\(\backslash\)n"}; }
\end{DoxyCode}
\hypertarget{page_rotations_rotations_interfaces_rotationmatrix}{}\doxysubsubsection{Rotation Matrix}\label{page_rotations_rotations_interfaces_rotationmatrix}
The class \mbox{\hyperlink{classkindr_1_1RotationMatrix}{kindr\+::\+Rotation\+Matrix}} implements a 3x3 rotation matrix representation of a rotation\+:

$\boxed{R = \begin{bmatrix} r_{11} & r_{12} & r_{13} \\ r_{21} & r_{22} & r_{23} \\ r_{31} & r_{32} & r_{33} \end{bmatrix} \in SO(3)}$

It stores the coefficients in Eigen\+::\+Matrix.

The following typedefs are provided for convenience\+:
\begin{DoxyItemize}
\item Rotation\+MatrixD for primitive type double
\item Rotation\+MatrixF for primitive type float
\end{DoxyItemize}\hypertarget{page_rotations_rotations_implementation_rotationmatrix_create}{}\doxyparagraph{Create a Rotation Matrix}\label{page_rotations_rotations_implementation_rotationmatrix_create}

\begin{DoxyCode}{0}
\DoxyCodeLine{RotationMatrixD rmat1;           \textcolor{comment}{// identity rotation: diag(1.0, 1.0, 1.0)}}
\DoxyCodeLine{RotationMatrixD rmat2(r11, r12, r13, \textcolor{comment}{// rotation matrix from coefficients}}
\DoxyCodeLine{           r21 ,r22, r23,}
\DoxyCodeLine{           r31, r32, r33);}
\DoxyCodeLine{Eigen::Matrix3d mat;             \textcolor{comment}{// rotation matrix from Eigen matrix}}
\DoxyCodeLine{mat << r11, r12, r13,}
\DoxyCodeLine{   r21 ,r22, r23,}
\DoxyCodeLine{   r31, r32, r33;}
\DoxyCodeLine{RotationMatrixD rmat3(mat);      \textcolor{comment}{// using the constructor   }}
\DoxyCodeLine{RotationMatrixD rmat4;           \textcolor{comment}{// using a setter}}
\DoxyCodeLine{rmat4.setMatrix(mat);}
\end{DoxyCode}
\hypertarget{page_rotations_rotations_implementation_rotationmatrix_use}{}\doxysubparagraph{Use a Rotation Matrix}\label{page_rotations_rotations_implementation_rotationmatrix_use}

\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::Matrix3d mat = rmat.matrix();                                  \textcolor{comment}{// get Eigen matrix (avoid using toImplementation())    }}
\DoxyCodeLine{Eigen::Vector3d vector\_rotated = rmat.rotate(Eigen::Vector3d(1.0,2.0,3.0));               \textcolor{comment}{// rotate a vector}}
\DoxyCodeLine{Eigen::Vector3d vector\_invrotated = rmat.inverseRotate(Eigen::Vector3d(1.0,2.0,3.0));         \textcolor{comment}{// reverse rotate a vector}}
\DoxyCodeLine{\textcolor{keywordtype}{double} determinant = rmat.determinant();                              \textcolor{comment}{// get the determinant of the matrix}}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"Rotation matrix: "} << rmat << std::endl:                        \textcolor{comment}{// output rotation matrix}}
\DoxyCodeLine{\textcolor{keywordflow}{if} (rmat == RotationMatrixD())                                    \textcolor{comment}{// compare }}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"Rotation is identity\(\backslash\)n"}; }
\end{DoxyCode}


Note that the rotation matrix is stored internally differently than created by the constructor! Therefore, you should access the matrix using the method \mbox{\hyperlink{classkindr_1_1RotationMatrix_a93ccfb7b70e137d66693fac5f80a5049}{matrix()}} instead of \mbox{\hyperlink{classkindr_1_1RotationMatrix_aaa56dc1cf71facd568c2dc878cb51500}{to\+Implementation()}}.\hypertarget{page_rotations_rotations_interfaces_eulerangles_zyx}{}\doxysubsubsection{Euler Angles Z\+YX}\label{page_rotations_rotations_interfaces_eulerangles_zyx}
The class \mbox{\hyperlink{classkindr_1_1EulerAnglesZyx}{kindr\+::\+Euler\+Angles\+Zyx}} implements the Euler Angles using the Z-\/\+Y-\/X convention\+:

$\boxed{(z, y, x),}$

where $z$ is the yaw angle, $y$ is the pitch angle, and $x$ is the roll angle. The consecutive rotations are shown in the following picture\+: 

The following typedefs are provided for convenience\+:
\begin{DoxyItemize}
\item Euler\+Angles\+ZyxD for primitive type double
\item Euler\+Angles\+ZyxF for primitive type float
\end{DoxyItemize}\hypertarget{page_rotations_rotations_implementation_eulerangleszyx_create}{}\doxyparagraph{Create Euler Angles Z\+YX}\label{page_rotations_rotations_implementation_eulerangleszyx_create}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double} yaw = 0.3;                 \textcolor{comment}{// angle around z-\/axis}}
\DoxyCodeLine{\textcolor{keywordtype}{double} pitch = 0.2;                   \textcolor{comment}{// angle around new y-\/axis}}
\DoxyCodeLine{\textcolor{keywordtype}{double} roll = 0.1;                    \textcolor{comment}{// angle around new x-\/axis}}
\DoxyCodeLine{EulerAnglesZyxD angles1;              \textcolor{comment}{// identity rotation (0, 0, 0)}}
\DoxyCodeLine{EulerAnglesZyxD angles2(yaw, pitch, roll);        }
\DoxyCodeLine{EulerAnglesZyxD angles3(Eigen::Vector3d(yaw, pitch, roll));       }
\end{DoxyCode}
\hypertarget{page_rotations_rotations_implementation_eulerangleszyx_use}{}\doxyparagraph{Use  Euler Angles Z\+YX}\label{page_rotations_rotations_implementation_eulerangleszyx_use}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double} roll = angles.roll();}
\DoxyCodeLine{\textcolor{keywordtype}{double} pitch = angles.pitch();}
\DoxyCodeLine{\textcolor{keywordtype}{double} yaw = angles.yaw();}
\DoxyCodeLine{roll = angles.x();}
\DoxyCodeLine{pitch = angles.y();}
\DoxyCodeLine{yaw = angles.z();}
\DoxyCodeLine{Eigen::Vector3d angleVector = angles.vector();    \textcolor{comment}{// [roll; pitch; yaw]}}
\DoxyCodeLine{angles.setUnique()                        \textcolor{comment}{// Modifies the angles, such that yaw in [-\/pi,pi), pitch in [-\/pi/2,pi/2), roll in [-\/pi,pi)}}
\end{DoxyCode}
\hypertarget{page_rotations_rotations_interfaces_eulerangles_xyz}{}\doxysubsubsection{Euler Angles X\+YZ}\label{page_rotations_rotations_interfaces_eulerangles_xyz}
The class \mbox{\hyperlink{classkindr_1_1EulerAnglesXyz}{kindr\+::\+Euler\+Angles\+Xyz}} implements the Euler Angles using the X-\/\+Y-\/Z convention\+:

$\boxed{(x, y, z ),}$

where $z$ is the yaw angle, $y$ is the pitch angle, and $x$ is the roll angle. The consecutive rotations are shown in the following picture\+: 

It stores the coefficients in Eigen\+::\+Vector3.

The following four typedefs are provided for convenience\+:
\begin{DoxyItemize}
\item Euler\+Angles\+XyzD for primitive type double
\item Euler\+Angles\+XyzF for primitive type float
\end{DoxyItemize}\hypertarget{page_rotations_rotations_implementation_euleranglesxyz_create}{}\doxyparagraph{Create Euler Angles X\+YZ}\label{page_rotations_rotations_implementation_euleranglesxyz_create}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double} roll = 0.1;                    \textcolor{comment}{// angle around x-\/axis}}
\DoxyCodeLine{\textcolor{keywordtype}{double} pitch = 0.2;                   \textcolor{comment}{// angle around new y-\/axis}}
\DoxyCodeLine{\textcolor{keywordtype}{double} yaw = 0.3;                 \textcolor{comment}{// angle around new z-\/axis}}
\DoxyCodeLine{EulerAnglesXyzD angles1;              \textcolor{comment}{// identity rotation (0, 0, 0)}}
\DoxyCodeLine{EulerAnglesXyzD angles2(roll, pitch, yaw);        }
\DoxyCodeLine{EulerAnglesXyzD angles3(Eigen::Vector3d(roll, pitch, yaw));}
\end{DoxyCode}
\hypertarget{page_rotations_rotations_implementation_euleranglesxyz_use}{}\doxyparagraph{Use Euler Angles X\+YZ}\label{page_rotations_rotations_implementation_euleranglesxyz_use}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double} roll = angles.roll();}
\DoxyCodeLine{\textcolor{keywordtype}{double} pitch = angles.pitch();}
\DoxyCodeLine{\textcolor{keywordtype}{double} yaw = angles.yaw();}
\DoxyCodeLine{roll = angles.x();}
\DoxyCodeLine{pitch = angles.y();}
\DoxyCodeLine{yaw = angles.z();}
\DoxyCodeLine{Eigen::Vector3d angleVector = angles.vector();    \textcolor{comment}{// [roll; pitch; yaw]}}
\DoxyCodeLine{angles.setUnique()                        \textcolor{comment}{// Modifies the angles, such that roll in [-\/pi,pi), pitch in [-\/pi/2,pi/2), yaw in [-\/pi,pi)}}
\end{DoxyCode}


~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 \hypertarget{page_poses}{}\doxysection{Poses}\label{page_poses}
This library defines an \mbox{\hyperlink{page_poses_poses_interface}{interface}} for a pose (position and orientation) of a rigid body or a (displacement) frame to enable different representations of a pose (homogeneous transformation, screw motion, etc.).\hypertarget{page_poses_poses_interface}{}\doxysubsection{Generic Interface}\label{page_poses_poses_interface}
The class \mbox{\hyperlink{classkindr_1_1PoseBase}{kindr\+::\+Pose\+Base}} serves as an interface for a pose of a rigid body, i.\+e. the position and orientation of a rigid body. All types of representations of a pose, such as homogeneous transformations and screw motions, are derived from this base class.\hypertarget{page_poses_poses_implementations}{}\doxysubsection{Parameterizations}\label{page_poses_poses_implementations}
\hypertarget{page_poses_poses_implementations_homtransform}{}\doxysubsubsection{Homogeneous Transformation}\label{page_poses_poses_implementations_homtransform}
$\boxed{\begin{bmatrix}{}_I\mathbf{r}_{I\!P} \\ 1 \end{bmatrix} = \mathbf{T}_{I\!B} \begin{bmatrix}{}_B\mathbf{r}_{B\!P}\\ 1 \end{bmatrix}, \quad \mathbf{T}_{I\!B} = \begin{bmatrix} \mathbf{C}_{I\!B} & {}_I\mathbf{r}_{I\!B} \\ 0^T & 1 \\ \end{bmatrix}, \quad \mathbf{T}_{I\!B}^{-1} =\mathbf{T}_{B\!I} = \begin{bmatrix} \mathbf{C}_{I\!B}^T & -\mathbf{C}_{I\!B}^T {}_I\mathbf{r}_{I\!B} \\ 0^T & 1 \\ \end{bmatrix}}$

The following typedefs are provided for convenience\+:
\begin{DoxyItemize}
\item Hom\+Transform\+QuatD for primitive type double (stores internally a rotation quaternion)
\item Hom\+Transform\+QuatF for primitive type float (stores internally a rotation quaternion)
\item Hom\+Transform\+MatrixD for primitive type double (stores internally a rotation matrix)
\item Hom\+Transform\+MatrixF for primitive type float (stores internally a rotation matrix)
\end{DoxyItemize}\hypertarget{page_poses_poses_implementation_homtransform}{}\doxyparagraph{Create a Homogeneous Transformation}\label{page_poses_poses_implementation_homtransform}

\begin{DoxyCode}{0}
\DoxyCodeLine{Position3D position;}
\DoxyCodeLine{RotationQuaternionD rotation;}
\DoxyCodeLine{HomTransformQuatD transform1;                       \textcolor{comment}{// identity tranformation}}
\DoxyCodeLine{HomTransformQuatD transform2(position, rotation);           \textcolor{comment}{// create with position and rotation}}
\end{DoxyCode}
\hypertarget{page_poses_poses_implementation_homtransform}{}\doxyparagraph{Create a Homogeneous Transformation}\label{page_poses_poses_implementation_homtransform}

\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::Matrix<double, 4, 4> matrix = transform1.getTransformationMatrix();        \textcolor{comment}{// gets the 4x4 transformation matrix}}
\DoxyCodeLine{transform1.setIdentity();                             \textcolor{comment}{// sets it to identity}}
\DoxyCodeLine{transform2.invert();                                  \textcolor{comment}{// invert transformation}}
\DoxyCodeLine{Eigen::Vector3d vector\_transform = transform2.rotate(Eigen::Vector3d(1.0,2.0,3.0));               \textcolor{comment}{// tranform a vector}}
\DoxyCodeLine{Eigen::Vector3d vector\_invtransform = transform2.inverseTransform(Eigen::Vector3d(1.0,2.0,3.0));          \textcolor{comment}{// reverse tranform a vector}}
\DoxyCodeLine{HomTransformQuatD transform3 = transform2*transform1;                             \textcolor{comment}{// composition of transformations}}
\end{DoxyCode}


~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 \hypertarget{page_rdiff}{}\doxysection{Time Derivatives of Rotations}\label{page_rdiff}
This library defines an \mbox{\hyperlink{page_rdiff_rdiff_interface}{interface}} for time derivatives of rotations to enable different representations of the time derivative (angular velocity, time derivatives of Euler angles, time derivative of quaternion, etc.). The section \mbox{\hyperlink{page_rdiff_rdiff_interface}{Interface}} describes the functionalities, whereas the section Parameterization shows some examples.\hypertarget{page_rdiff_rdiff_interface}{}\doxysubsection{Generic Interface}\label{page_rdiff_rdiff_interface}
The class \mbox{\hyperlink{classkindr_1_1RotationDiffBase}{kindr\+::\+Rotation\+Diff\+Base}} serves as an interface for the time derivative of a rotation. All types of representations of a time derivative of a rotation, such as angular velocity and time derivatives of Euler angles, are derived from this base class.\hypertarget{page_rdiff_rdiff_interfaces_otationdiff_type}{}\doxysubsubsection{Type of a Time Derivative of a Rotation}\label{page_rdiff_rdiff_interfaces_otationdiff_type}
The type of a rotation is defined by
\begin{DoxyItemize}
\item the \mbox{\hyperlink{page_rdiff_rdiff_interfaces_representations}{kind of parameterization}} (derivative of quaternion, rotation matrix, etc.),
\item the primitive data type of the parameters (float/double, etc.) and
\end{DoxyItemize}\hypertarget{page_rdiff_rdiff_interfaces_rotationdiff_constructor}{}\doxysubsubsection{Construction of  a Time Derivative of a Rotation}\label{page_rdiff_rdiff_interfaces_rotationdiff_constructor}
The default constructor always initializes all derivatives with zero.\hypertarget{page_rdiff_rdiff_zero}{}\doxysubsubsection{Zero Time Derivatives}\label{page_rdiff_rdiff_zero}
All derivatives can be set to zero by the function \mbox{\hyperlink{classkindr_1_1RotationDiffBase_a671d5efef5d1e39edeb89c04e370e59d}{set\+Zero()}}.\hypertarget{page_rdiff_rdiff_addition_and_subtraction}{}\doxysubsubsection{Addition and Subtraction}\label{page_rdiff_rdiff_addition_and_subtraction}
Addition and subtraction of the time derivatives are provided by the kindr\+::\+Rotation\+Diff\+Base\+::operator+ and kindr\+::\+Rotation\+Diff\+Base\+::operator-\/, respectively.\hypertarget{page_rdiff_rdiff_conversion}{}\doxysubsubsection{Conversion between Time Derivatives of Rotations}\label{page_rdiff_rdiff_conversion}
There are three kinds of conversions\+:
\begin{DoxyItemize}
\item Conversion between different representations, i.\+e. between different parameterizations (e.\+g. rotation quaternion -\/ angle-\/axis)
\item Conversion between different primitive data types (e.\+g. float -\/ double)
\end{DoxyItemize}\hypertarget{page_rdiff_rdiff_interfaces_conversion_representations}{}\doxyparagraph{Conversion between Representations}\label{page_rdiff_rdiff_interfaces_conversion_representations}
The following methods allow to convert between different representations of a rotation\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{LocalAngularVelocityD angularVelocity;                              \textcolor{comment}{// representation of the time derivative}}
\DoxyCodeLine{RotationQuaternionD rotationQuaternion;                         \textcolor{comment}{// the rotation the derivative is taken}}
\DoxyCodeLine{RotationQuaternionDiffD rotationQuaternionDiff(rotationQuaternion, angularVelocity);        \textcolor{comment}{// convert using the constructor}}
\DoxyCodeLine{rotationQuaternionDiff = angularVelocity.cast<RotationQuaternionDiffD>(rotationQuaternion); \textcolor{comment}{// convert using the cast method}}
\end{DoxyCode}
\hypertarget{page_rdiff_rdiff_interfaces_conversion_primtype}{}\doxyparagraph{Conversion between Primitive Data Types}\label{page_rdiff_rdiff_interfaces_conversion_primtype}
Not yet supported.\hypertarget{page_rdiff_rdiff_interfaces_representations}{}\doxyparagraph{Representations of Time Derivatives of Rotations}\label{page_rdiff_rdiff_interfaces_representations}
The following representations are currently provided by the library\+:\hypertarget{page_rdiff_rdiff_interfaces_angularvelocity}{}\doxysubsubsection{Local Angular Velocity}\label{page_rdiff_rdiff_interfaces_angularvelocity}
The class \mbox{\hyperlink{classkindr_1_1LocalAngularVelocity}{kindr\+::\+Local\+Angular\+Velocity}} implements the local angular velocity in 3D-\/\+Space. The angular velocity expressed in body-\/fixed frame can be stated as\+:

$\boxed{{}_B\mathbf{\omega}_{I\,B} = \begin{bmatrix} \omega_x \\ \omega_y \\ \omega_z \end{bmatrix}}$

It stores the three coordinates of the angular velocity in Eigen\+::\+Matrix$<$\+Prim\+Type, 3, 1$>$.

The following two typedefs are provided for convenience\+:
\begin{DoxyItemize}
\item Angular\+VelocityD for primitive type double
\item Angular\+VelocityF for primitive type float
\end{DoxyItemize}

An angular velocity can be created as follows\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{double} w\_x = 1.0;}
\DoxyCodeLine{\textcolor{keywordtype}{double} w\_y = 2.0;}
\DoxyCodeLine{\textcolor{keywordtype}{double} w\_z = 3.0;}
\DoxyCodeLine{LocalAngularVelocityD velocity1();                      \textcolor{comment}{// creates a 3D-\/Velocity with all coordinates equal to zero}}
\DoxyCodeLine{LocalAngularVelocityD velocity2(w\_x, w\_y, w\_z);             \textcolor{comment}{// initializes the three coordinates}}
\DoxyCodeLine{LocalAngularVelocityD velocity3(Eigen::Vector3d(w\_x, w\_y, w\_z));    \textcolor{comment}{// creates a velocity from an Eigen vector}}
\end{DoxyCode}


The coordinates can be obtained as follows\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{w\_x = velocity1.x();}
\DoxyCodeLine{w\_y = velocity1.y();}
\DoxyCodeLine{w\_z = velocity1.z();}
\DoxyCodeLine{Eigen::Vector3d vector = velocity1.toImplementation();  \textcolor{comment}{// [w\_x;w\_y;w\_z]}}
\end{DoxyCode}


Operations with angular velocities\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{LocalAngularVelocityD velocity4 = velocity1 + velocity2;  \textcolor{comment}{// addition}}
\DoxyCodeLine{LocalAngularVelocityD velocity3 -\/= velocity1;     \textcolor{comment}{// subtraction}}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"Velocity 3 is: "} << velocity3;      \textcolor{comment}{// print velocity}}
\end{DoxyCode}
\hypertarget{page_rdiff_rdiff_interfaces_rotationquaterniondiff}{}\doxysubsubsection{Time Derivative of Rotation Quaternion}\label{page_rdiff_rdiff_interfaces_rotationquaterniondiff}
The class \mbox{\hyperlink{classkindr_1_1RotationQuaternionDiff}{kindr\+::\+Rotation\+Quaternion\+Diff}} implements the time derivative of a Hamiltonian unit quaternion representation of a rotation\+:

$\boxed{\begin{aligned}\dot{P} &= p_0 + p_1 i + p_2 j + p_3 k \in \mathbb{H}, \quad p_i \in \mathbb{R} \\ i^2 &= j^2=k^2 = ijk = -1 \\ \end{aligned}}$\hypertarget{page_rdiff_rdiff_interfaces_rotationmatrixdiff}{}\doxysubsubsection{Time Derivative of Rotation Matrix}\label{page_rdiff_rdiff_interfaces_rotationmatrixdiff}
The class \mbox{\hyperlink{classkindr_1_1RotationMatrixDiff}{kindr\+::\+Rotation\+Matrix\+Diff}} implements the time derivative of a 3x3 rotation matrix representation of a rotation\+:

$\boxed{\dot{C} = \begin{bmatrix} r_{11} & r_{12} & r_{13} \\ r_{21} & r_{22} & r_{23} \\ r_{31} & r_{32} & r_{33} \end{bmatrix}}$\hypertarget{page_rdiff_rdiff_interfaces_eulerangles_zyx_diff}{}\doxysubsubsection{Time derivative of Euler Angles Z\+YX}\label{page_rdiff_rdiff_interfaces_eulerangles_zyx_diff}
The class \mbox{\hyperlink{classkindr_1_1EulerAnglesZyxDiff}{kindr\+::\+Euler\+Angles\+Zyx\+Diff}} implements the time derivatives of the Euler angles with the Z-\/\+Y-\/X convention\+:

$\boxed{(\dot{z}, \dot{y}, \dot{x} ),}$

where $\dot{z}$ is the time derivative of the yaw angle, $\dot{y}$ is the time derivative of the pitch angle, and $\dot{x}$ is the time derivative of the roll angle.\hypertarget{page_rdiff_rdiff_interfaces_eulerangles_xyz_diff}{}\doxysubsubsection{Time Derivative of Euler Angles X\+YZ}\label{page_rdiff_rdiff_interfaces_eulerangles_xyz_diff}
The class \mbox{\hyperlink{classkindr_1_1EulerAnglesXyzDiff}{kindr\+::\+Euler\+Angles\+Xyz\+Diff}} implements the time derivatives of the Euler angles with the X-\/\+Y-\/Z convention\+:

$\boxed{(\dot{x}, \dot{y}, \dot{z},}$

where $\dot{z}$ is the time derivative of the yaw angle, $\dot{y}$ is the time derivative of the pitch angle, and $\dot{x}$ is the time derivative of the roll angle.

~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 \hypertarget{page_posesdiff}{}\doxysection{Time Derivatives of Poses}\label{page_posesdiff}
This library defines an \mbox{\hyperlink{page_posesdiff_posesdiff_interface}{interface}} for the time derivative of a pose (position and orientation) of a rigid body or a (displacement) frame to enable different representations of a time derivative of a pose (twist, etc.).\hypertarget{page_posesdiff_posesdiff_interface}{}\doxysubsection{Generic Interface}\label{page_posesdiff_posesdiff_interface}
The class \mbox{\hyperlink{classkindr_1_1PoseDiffBase}{kindr\+::\+Pose\+Diff\+Base}} serves as an interface for the time derivative of a pose of a rigid body, i.\+e. the position and orientation of a rigid body. All types of representations of time derivatives of a pose, such as twist motions, are derived from this base class.\hypertarget{page_posesdiff_posesdiff_implementations}{}\doxysubsection{Parameterizations}\label{page_posesdiff_posesdiff_implementations}
\hypertarget{page_posesdiff_posesdiff_implementations_twist}{}\doxysubsubsection{Twist}\label{page_posesdiff_posesdiff_implementations_twist}
The class \mbox{\hyperlink{classkindr_1_1Twist}{kindr\+::\+Twist}} implements a 6d twist\+:

$\boxed{\mathbf{\phi} = \begin{pmatrix} {}_B\mathbf{v}_B \\ {}_B\mathbf{\omega}_{I\!B}\end{pmatrix}}$

where ${}_B\mathbf{v}_B$ is the linear velocity in body-\/fixed frame and ${}_B\mathbf{\omega}_{I\!B}$ is the local angular velocity.

~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 \hypertarget{page_quaternion}{}\doxysection{Quaternions}\label{page_quaternion}
This library defines an \mbox{\hyperlink{page_quaternion_quaternion_interface}{interface}} for quaternions to enable different \mbox{\hyperlink{page_quaternion_quaternion_implementations}{implementations}}.

Note that these quaternions should not be used to represent rotations! Use a \mbox{\hyperlink{classkindr_1_1RotationQuaternion}{Rotation\+Quaternion}} instead as explained on page \mbox{\hyperlink{page_rotations}{Rotations}}.\hypertarget{page_quaternion_quaternion_interface}{}\doxysubsection{Interfaces}\label{page_quaternion_quaternion_interface}
The interfaces are declared in \mbox{\hyperlink{QuaternionBase_8hpp_source}{Quaternion\+Base.\+hpp}}. \hypertarget{page_quaternion_generic_quaternion}{}\doxysubsubsection{Generic Quaternion}\label{page_quaternion_generic_quaternion}
The class \mbox{\hyperlink{classkindr_1_1QuaternionBase}{kindr\+::\+Quaternion\+Base}} defines the {\itshape interface} for a Hamiltonian generic quaternion defined as\+:

$\boxed{\begin{aligned}Q &= q_0 + q_1 i + q_2 j + q_3 k \in \mathbb{H}, \quad q_i \in \mathbb{R} \\ i^2 &= j^2=k^2 = ijk = -1 \\ \end{aligned}}$

The interface defines generic functions, such as\+:
\begin{DoxyItemize}
\item inversion (\mbox{\hyperlink{classkindr_1_1QuaternionBase_a5703255b0fe88a97b267c1e287eb6070}{kindr\+::\+Quaternion\+Base\+::invert()}})
\item conjugation (\mbox{\hyperlink{classkindr_1_1QuaternionBase_aa22b1d523f8951a0e0debc4a265d2b87}{kindr\+::\+Quaternion\+Base\+::conjugate()}})
\item multiplication (\mbox{\hyperlink{classkindr_1_1QuaternionBase_a45bd9cac0b6a15b765c02fb506c1ffc3}{kindr\+::\+Quaternion\+Base\+::operator$\ast$()}})
\item comparison (\mbox{\hyperlink{classkindr_1_1QuaternionBase_a307e00f8e0c58c6f127fede27c1232e0}{kindr\+::\+Quaternion\+Base\+::operator==()}})
\end{DoxyItemize}\hypertarget{page_quaternion_unit_quternion}{}\doxysubsubsection{Unit Quaternion}\label{page_quaternion_unit_quternion}
The class \mbox{\hyperlink{classkindr_1_1UnitQuaternionBase}{kindr\+::\+Unit\+Quaternion\+Base}} defines the {\itshape interface} for a Hamiltonian unit quaternion defined as\+:

$\boxed{\begin{aligned}P &= p_0 + p_1 i + p_2 j + p_3 k \in \mathbb{H}, \quad p_i \in \mathbb{R} \\ i^2 &= j^2=k^2 = ijk = -1, \quad \lVert P \rVert= \sqrt{p_0^2 + p_1^2 + p_2^2 + p_3^2} = 1 \\ \end{aligned}}$

There are two reasons why there is an extra class for unit quaternions\+:
\begin{DoxyItemize}
\item Mathematical properties of a unit quaternion, such as the inverse is equal to the conjugate, can be exploited to increase computational speed.
\item The unit length can be guaranteed.
\end{DoxyItemize}\hypertarget{page_quaternion_quaternion_implementations}{}\doxysubsection{Implementation}\label{page_quaternion_quaternion_implementations}
Eigen provides a Eigen\+::\+Quaternion, which is used as a primitive for a quaternion.

To use the quaternions based on Eigen, include the following header\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <kindr/Core>}}
\end{DoxyCode}
\hypertarget{page_quaternion_generic_quaternion_eigen}{}\doxysubsubsection{Generic Quaternion}\label{page_quaternion_generic_quaternion_eigen}
The class \mbox{\hyperlink{classkindr_1_1Quaternion}{kindr\+::\+Quaternion}} implements a Hamiltonian generic quaternion.

The coefficients are defined as

$\boxed{Q = w + x i + yj + z k}$

The following two typedefs are provided for convenience\+:
\begin{DoxyItemize}
\item QuaternionF for float
\item QuaternionD for double
\end{DoxyItemize}

Example code to create a quaternion\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{namespace }quat = kindr::eigen\_impl; \textcolor{comment}{// select implementation based on Eigen}}
\DoxyCodeLine{\mbox{\hyperlink{classkindr_1_1Quaternion}{quat::QuaternionD}} quat1;                \textcolor{comment}{// creates a quaternion with all coefficients equal to zero}}
\DoxyCodeLine{\mbox{\hyperlink{classkindr_1_1Quaternion}{quat::QuaternionD}} quat2(1.0, 2.0, 3.0, 4.0); \textcolor{comment}{//creates a quaternion with w=1, x=2, y=3, z=4 }}
\end{DoxyCode}
\hypertarget{page_quaternion_unit_quaternion_eigen}{}\doxysubsubsection{Unit Quaternion}\label{page_quaternion_unit_quaternion_eigen}
The class \mbox{\hyperlink{classkindr_1_1UnitQuaternion}{kindr\+::\+Unit\+Quaternion}} implements a Hamiltonian unit quaternion.

The following two typedefs are provided for convenience\+:
\begin{DoxyItemize}
\item Unit\+QuaternionF for float
\item Unit\+QuaternionD for double
\end{DoxyItemize}

The class only checks if the quaternion has unit length if the code is built with debugging symbols, i.\+e. \#define N\+D\+E\+B\+UG exists. If the unit quaternion has not unit length, an exception will be thrown. ~\newline
\hypertarget{page_quaternion_generic_unit_quaternion_eigen}{}\doxysubsubsection{Conversion between Generic Quaternion and Unit Quaternion}\label{page_quaternion_generic_unit_quaternion_eigen}
Conversion by constructor\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{UnitQuaternionD uquat;}
\DoxyCodeLine{QuaternionD quat(uquat);}
\DoxyCodeLine{UnitQuaternionD uquat2(quat); \textcolor{comment}{// error (not allowed)}}
\DoxyCodeLine{UnitQuaternionD uquat3(quat.toUnitQuaternion()); \textcolor{comment}{// normalizes the quaternion}}
\end{DoxyCode}


Conversion by assignment\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{UnitQuaternionD uquat;}
\DoxyCodeLine{QuaternionD quat;}
\DoxyCodeLine{quat = uquat;}
\DoxyCodeLine{uquat = quat; \textcolor{comment}{// error (not allowed)}}
\DoxyCodeLine{uquat = quat.toUnitQuaternion();  \textcolor{comment}{// normalizes the quaternion}}
\end{DoxyCode}


~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 \hypertarget{page_vector}{}\doxysection{Vectors}\label{page_vector}
This library defines a \mbox{\hyperlink{page_vector_vectors_interface}{interface}} for a vector. It is possible to assign a certain physical type to the vector, such as position or velocity. The section \mbox{\hyperlink{page_vector_vectors_interface}{Interface}} describes the functionalities, whereas the section \mbox{\hyperlink{page_vector_vectors_implementations}{Implementation}} shows some examples.\hypertarget{page_vector_vectors_interface}{}\doxysubsection{Interface}\label{page_vector_vectors_interface}
The class \mbox{\hyperlink{classkindr_1_1VectorBase}{kindr\+::\+Vector\+Base}} serves as an interface for a vector. Vectors of all physical types are derived from this base class.\hypertarget{page_vector_physical_quantities}{}\doxysubsubsection{Physical quantities\+:}\label{page_vector_physical_quantities}
The following representations are currently provided by the library\+:


\begin{DoxyItemize}
\item Typeless
\item Time
\item Mass
\item Inertia
\item Power
\item Energy
\item Jerk
\item Acceleration
\item Velocity
\item Position
\item Force
\item Momentum
\item Angular\+Jerk
\item Angular\+Acceleration
\item Angular\+Velocity
\item Angle
\item Torque
\item Angular\+Momentum
\end{DoxyItemize}\hypertarget{page_vector_vectors_constructor}{}\doxysubsubsection{Constructor}\label{page_vector_vectors_constructor}
The default constructor always initializes all coordinates equal to zero. Other (explicit) constructors use another vector or the implementation type. If the dimension of the vector is three, there is a constructor which accepts x, y and z as arguments.\hypertarget{page_vector_vectors_operators}{}\doxysubsubsection{Operators}\label{page_vector_vectors_operators}
All possible operators (+, -\/, $\ast$, /, +=, -\/=, $\ast$=, /=, (), $<$$<$) can be used for a vector object. However it is not possible to add or subtract vectors of different physical types. Elementwise multiplication and division is only possible for predefined triples of physical types. The \mbox{\hyperlink{classkindr_1_1VectorBase_ab63060e07f78158c997c90ddcd3cf450}{dot}} product can be used, as well as the \mbox{\hyperlink{classkindr_1_1VectorBase_a83deeb9432d3be2371a544728e70b31e}{cross}} product (for vectors of dimension three).\hypertarget{page_vector_vectors_other_methods}{}\doxysubsubsection{Other methods}\label{page_vector_vectors_other_methods}
All coordinates can be set to zero by the function \mbox{\hyperlink{classkindr_1_1VectorBase_a406f24d1389e023c528e9ed9f4c032e2}{set\+Zero()}}. The vector can be normalized with \mbox{\hyperlink{classkindr_1_1VectorBase_a9c83ab432d9ad5eaa876bdbef08610e8}{normalize()}}. There are methods which return the \mbox{\hyperlink{classkindr_1_1VectorBase_aca063fe9905a5f3f24fb921fe113c1a5}{biggest}} or the \mbox{\hyperlink{classkindr_1_1VectorBase_aae3017e3364dd3454786189056638a7b}{smallest}} element, the \mbox{\hyperlink{classkindr_1_1VectorBase_a944bcb5a5e780f95def5ba3d88eb302f}{sum}} or the \mbox{\hyperlink{classkindr_1_1VectorBase_a34d743a5f1f76f68eca81fa6207f5b5b}{mean}} of the entries. If the dimension of the vector is three, the coordinates can be accessed by x(), y() and z().\hypertarget{page_vector_vectors_implementations}{}\doxysubsection{Implementations}\label{page_vector_vectors_implementations}
All types can be included by 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <kindr/Core>}}
\end{DoxyCode}
 and lie within the namespace kindr.

~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 ~\newline
 